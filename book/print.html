<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Bitcoin Cookbook</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A cookbook for Rust Bitcoin development">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Bitcoin Cookbook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is created and maintained by those involved in the
<a href="https://github.com/rust-bitcoin"><code>rust-bitcoin</code></a> GitHub organization, contributions are
appreciated. It covers various crates from the org and as such, aims to be useful to developers
wanting to write code in Rust that interacts with the Bitcoin network. It is specifically not
limited to just the <a href="https://github.com/rust-bitcoin/rust-bitcoin"><code>rust-bitcoin</code></a> crate, although
that is a good starting point if you want a one-stop-shop for interacting with Bitcoin in Rust.</p>
<p>There are a number of good libraries outside of the <code>rust-bitcoin</code> organization that use the crates
covered here, two that you might like to check out are:</p>
<ul>
<li><a href="https://bitcoindevkit.org/"><code>Bitcoin Dev Kit</code></a></li>
<li><a href="https://lightningdevkit.org/"><code>Lightning Dev Kit</code></a></li>
</ul>
<p>Finally, this book is currently a work in progress but hopes to eventually cover various topics,
including parsing blocks and transactions, constructing and signing transactions, receiving data
over the peer-to-peer network, plus fun stuff you can do with miniscript.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="getting_started.html">Getting Started</a></li>
<li><a href="tx.html">Constructing and Signing Transactions</a>
<ol>
<li><a href="tx_segwit-v0.html">SegWit V0</a></li>
<li><a href="tx_taproot.html">Taproot</a></li>
</ol>
</li>
<li><a href="psbt.html">Working with PSBTs</a>
<ol>
<li>Constructing and Signing Multiple Inputs:
<ol>
<li><a href="psbt/multiple_inputs_segwit-v0.html">SegWit V0</a></li>
<li><a href="psbt/multiple_inputs_taproot.html">Taproot</a></li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This website is licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0 Universal (CC0 1.0) Public Domain Dedication</a>.</p>
<p><a href="https://creativecommons.org/publicdomain/zero/1.0/"><img src="https://licensebuttons.net/l/by-sa/4.0/88x31.png" alt="CC BY-SA 4.0" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>To add <code>rust-bitcoin</code> to your project, run:</p>
<pre><code class="language-bash">cargo add bitcoin
</code></pre>
<p>If you are just exploring you probably want to use the "rand-std" feature so you can generate random keys:</p>
<pre><code class="language-bash">cargo add bitcoin --features=rand-std
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructing-and-signing-transactions"><a class="header" href="#constructing-and-signing-transactions">Constructing and Signing Transactions</a></h1>
<p>We provide the following examples:</p>
<ul>
<li><a href="tx_segwit-v0.html">Constructing and Signing Transactions - SegWit V0</a></li>
<li><a href="tx_taproot.html">Constructing and Signing Transactions - Taproot</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constructing-and-signing-transactions---segwit-v0"><a class="header" href="#constructing-and-signing-transactions---segwit-v0">Constructing and Signing Transactions - SegWit V0</a></h1>
<p>In this section, we will construct a <a href="https://bitcoinops.org/en/topics/segregated-witness/">SegWit V0 transaction</a>.
This is the most common type of transaction on the Bitcoin network today<sup class="footnote-reference" id="fr-today-1"><a href="#footnote-today">1</a></sup>.</p>
<p>This is the <code>cargo</code> commands that you need to run this example:</p>
<pre><code class="language-bash">cargo add bitcoin --features "std, rand-std"
</code></pre>
<p>First we'll need to import the following:</p>
<pre><code class="language-rust">use std::str::FromStr;

use bitcoin::hashes::Hash;
use bitcoin::locktime::absolute;
use bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing};
use bitcoin::sighash::{EcdsaSighashType, SighashCache};
use bitcoin::{
    transaction, Address, Amount, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut,
    Txid, WPubkeyHash, Witness,
};</code></pre>
<p>Here is the logic behind these imports:</p>
<ul>
<li><code>std::str::FromStr</code> is used to parse strings into Bitcoin primitives</li>
<li><code>bitcoin::hashes::Hash</code> is used to hash data</li>
<li><code>bitcoin::locktime::absolute</code> is used to create a locktime</li>
<li><code>bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing}</code> is used to sign transactions</li>
<li><code>bitcoin::sighash::{EcdsaSighashType, SighashCache}</code> is used to create sighashes</li>
<li><code>bitcoin::{Address, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut, Txid, WPubkeyHash, Witness}</code> is used to construct transactions</li>
</ul>
<p>Next, we define the following constants:</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::Amount;
</span>const DUMMY_UTXO_AMOUNT: Amount = Amount::from_sat(20_000_000);
const SPEND_AMOUNT: Amount = Amount::from_sat(5_000_000);
const CHANGE_AMOUNT: Amount = Amount::from_sat(14_999_000); // 1000 sat fee.</code></pre>
<ul>
<li><code>DUMMY_UTXO_AMOUNT</code> is the amount of the dummy UTXO we will be spending</li>
<li><code>SPEND_AMOUNT</code> is the amount we will be spending from the dummy UTXO</li>
<li><code>CHANGE_AMOUNT</code><sup class="footnote-reference" id="fr-change-1"><a href="#footnote-change">2</a></sup> is the amount we will be sending back to ourselves as change</li>
</ul>
<p>Before we can construct the transaction, we need to define some helper functions<sup class="footnote-reference" id="fr-expect-1"><a href="#footnote-expect">3</a></sup>:</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::secp256k1::{rand, Secp256k1, SecretKey, Signing};
</span><span class="boring">use bitcoin::WPubkeyHash;
</span>fn senders_keys&lt;C: Signing&gt;(secp: &amp;Secp256k1&lt;C&gt;) -&gt; (SecretKey, WPubkeyHash) {
    let sk = SecretKey::new(&amp;mut rand::thread_rng());
    let pk = bitcoin::PublicKey::new(sk.public_key(secp));
    let wpkh = pk.wpubkey_hash().expect("key is compressed");

    (sk, wpkh)
}</code></pre>
<p><code>senders_keys</code> generates a random private key and derives the corresponding public key hash.
This will be useful to mock a sender.
In a real application these would be actual secrets<sup class="footnote-reference" id="fr-secp-1"><a href="#footnote-secp">4</a></sup>.
We use the <code>SecretKey::new</code> method to generate a random private key <code>sk</code>.
We then use the <code>PublicKey::new</code> method to derive the corresponding public key <code>pk</code>.
Finally, we use the <code>PublicKey::wpubkey_hash</code> method to derive the corresponding public key hash <code>wpkh</code>.
Note that <code>senders_keys</code> is generic over the <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/trait.Signing.html"><code>Signing</code></a> trait.
This is used to indicate that is an instance of <code>Secp256k1</code> and can be used for signing.
We conclude returning the private key <code>sk</code> and the public key hash <code>wpkh</code> as a tuple.</p>
<pre><code class="language-rust"><span class="boring">use std::str::FromStr;
</span><span class="boring">use bitcoin::{Address, Network};
</span>fn receivers_address() -&gt; Address {
    Address::from_str("bc1q7cyrfmck2ffu2ud3rn5l5a8yv6f0chkp0zpemf")
        .expect("a valid address")
        .require_network(Network::Bitcoin)
        .expect("valid address for mainnet")
}</code></pre>
<p><code>receivers_address</code> generates a receiver address.
In a real application this would be the address of the receiver.
We use the method <code>Address::from_str</code> to parse the string <code>"bc1q7cyrfmck2ffu2ud3rn5l5a8yv6f0chkp0zpemf"</code> into an address.
Hence, it is necessary to import the <code>std::str::FromStr</code> trait.
Note that <code>bc1q7cyrfmck2ffu2ud3rn5l5a8yv6f0chkp0zpemf</code> is a <a href="https://bitcoinops.org/en/topics/bech32/">Bech32</a> address.
This is an arbitrary, however valid, Bitcoin mainnet address.
Hence we use the <code>require_network</code> method to ensure that the address is valid for mainnet.</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::{Amount, OutPoint, ScriptBuf, TxOut, Txid, WPubkeyHash};
</span><span class="boring">use bitcoin::hashes::Hash;
</span><span class="boring">const DUMMY_UTXO_AMOUNT: Amount = Amount::from_sat(20_000_000);
</span>fn dummy_unspent_transaction_output(wpkh: &amp;WPubkeyHash) -&gt; (OutPoint, TxOut) {
    let script_pubkey = ScriptBuf::new_p2wpkh(wpkh);

    let out_point = OutPoint {
        txid: Txid::all_zeros(), // Obviously invalid.
        vout: 0,
    };

    let utxo = TxOut { value: DUMMY_UTXO_AMOUNT, script_pubkey };

    (out_point, utxo)
}</code></pre>
<p><code>dummy_unspent_transaction_output</code> generates a dummy unspent transaction output (UTXO).
This is a SegWit V0 P2WPKH (<code>ScriptBuf::new_p2wpkh</code>) UTXO with a dummy invalid transaction ID (<code>txid: Txid::all_zeros()</code>),
and a value of the <code>const DUMMY_UTXO_AMOUNT</code> that we defined earlier.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.OutPoint.html"><code>OutPoint</code></a> struct to represent the transaction output.
Finally, we return the tuple <code>(out_point, utxo)</code>.</p>
<p>Now we are ready for our main function that will sign a transaction that spends a <code>p2wpkh</code> unspent output:</p>
<pre><code class="language-rust"><span class="boring">use std::str::FromStr;
</span><span class="boring">
</span><span class="boring">use bitcoin::hashes::Hash;
</span><span class="boring">use bitcoin::locktime::absolute;
</span><span class="boring">use bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing};
</span><span class="boring">use bitcoin::sighash::{EcdsaSighashType, SighashCache};
</span><span class="boring">use bitcoin::{
</span><span class="boring">    transaction, Address, Amount, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut,
</span><span class="boring">    Txid, WPubkeyHash, Witness,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const DUMMY_UTXO_AMOUNT: Amount = Amount::from_sat(20_000_000);
</span><span class="boring">const SPEND_AMOUNT: Amount = Amount::from_sat(5_000_000);
</span><span class="boring">const CHANGE_AMOUNT: Amount = Amount::from_sat(14_999_000); // 1000 sat fee.
</span><span class="boring">
</span><span class="boring">fn senders_keys&lt;C: Signing&gt;(secp: &amp;Secp256k1&lt;C&gt;) -&gt; (SecretKey, WPubkeyHash) {
</span><span class="boring">    let sk = SecretKey::new(&amp;mut rand::thread_rng());
</span><span class="boring">    let pk = bitcoin::PublicKey::new(sk.public_key(secp));
</span><span class="boring">    let wpkh = pk.wpubkey_hash().expect("key is compressed");
</span><span class="boring">
</span><span class="boring">    (sk, wpkh)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">fn receivers_address() -&gt; Address {
</span><span class="boring">    Address::from_str("bc1q7cyrfmck2ffu2ud3rn5l5a8yv6f0chkp0zpemf")
</span><span class="boring">        .expect("a valid address")
</span><span class="boring">        .require_network(Network::Bitcoin)
</span><span class="boring">        .expect("valid address for mainnet")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn dummy_unspent_transaction_output(wpkh: &amp;WPubkeyHash) -&gt; (OutPoint, TxOut) {
</span><span class="boring">    let script_pubkey = ScriptBuf::new_p2wpkh(wpkh);
</span><span class="boring">
</span><span class="boring">    let out_point = OutPoint {
</span><span class="boring">       txid: Txid::all_zeros(), // Obviously invalid.
</span><span class="boring">       vout: 0,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let utxo = TxOut { value: DUMMY_UTXO_AMOUNT, script_pubkey };
</span><span class="boring">
</span><span class="boring">    (out_point, utxo)
</span><span class="boring">}
</span>
fn main() {
    let secp = Secp256k1::new();

    // Get a secret key we control and the pubkeyhash of the associated pubkey.
    // In a real application these would come from a stored secret.
    let (sk, wpkh) = senders_keys(&amp;secp);

    // Get an address to send to.
    let address = receivers_address();

    // Get an unspent output that is locked to the key above that we control.
    // In a real application these would come from the chain.
    let (dummy_out_point, dummy_utxo) = dummy_unspent_transaction_output(&amp;wpkh);

    // The input for the transaction we are constructing.
    let input = TxIn {
        previous_output: dummy_out_point, // The dummy output we are spending.
        script_sig: ScriptBuf::default(), // For a p2wpkh script_sig is empty.
        sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,
        witness: Witness::default(), // Filled in after signing.
    };

    // The spend output is locked to a key controlled by the receiver.
    let spend = TxOut { value: SPEND_AMOUNT, script_pubkey: address.script_pubkey() };

    // The change output is locked to a key controlled by us.
    let change = TxOut {
        value: CHANGE_AMOUNT,
        script_pubkey: ScriptBuf::new_p2wpkh(&amp;wpkh), // Change comes back to us.
    };

    // The transaction we want to sign and broadcast.
    let mut unsigned_tx = Transaction {
        version: transaction::Version::TWO,  // Post BIP-68.
        lock_time: absolute::LockTime::ZERO, // Ignore the locktime.
        input: vec![input],                  // Input goes into index 0.
        output: vec![spend, change],         // Outputs, order does not matter.
    };
    let input_index = 0;

    // Get the sighash to sign.
    let sighash_type = EcdsaSighashType::All;
    let mut sighasher = SighashCache::new(&amp;mut unsigned_tx);
    let sighash = sighasher
        .p2wpkh_signature_hash(input_index, &amp;dummy_utxo.script_pubkey, DUMMY_UTXO_AMOUNT, sighash_type)
        .expect("failed to create sighash");

    // Sign the sighash using the secp256k1 library (exported by rust-bitcoin).
    let msg = Message::from(sighash);
    let signature = secp.sign_ecdsa(&amp;msg, &amp;sk);

    // Update the witness stack.
    let signature = bitcoin::ecdsa::Signature { signature, sighash_type };
    let pk = sk.public_key(&amp;secp);
    *sighasher.witness_mut(input_index).unwrap() = Witness::p2wpkh(&amp;signature, &amp;pk);

    // Get the signed transaction.
    let tx = sighasher.into_transaction();

    // BOOM! Transaction signed and ready to broadcast.
    println!("{:#?}", tx);
}</code></pre>
<p>Let's go over the main function code block by block.</p>
<p><code>let secp = Secp256k1::new();</code> creates a new <code>Secp256k1</code> context with all capabilities.
Since we added the <code>rand-std</code> feature to our <code>Cargo.toml</code>,
we can use the <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/struct.Secp256k1.html#method.new"><code>SecretKey::new</code></a> method to generate a random private key <code>sk</code>.</p>
<p><code>let (sk, wpkh) = senders_keys(&amp;secp);</code> generates a random private key <code>sk</code> and derives the corresponding public key hash <code>wpkh</code>.
<code>let address = receivers_address();</code> generates a receiver's address <code>address</code>.
<code>let (dummy_out_point, dummy_utxo) = dummy_unspent_transaction_output(&amp;wpkh);</code> generates a dummy unspent transaction output <code>dummy_utxo</code> and its corresponding outpoint <code>dummy_out_point</code>.
All of these are helper functions that we defined earlier.</p>
<p><code>let script_code = dummy_utxo.script_pubkey.p2wpkh_script_code().expect("valid script");</code>
creates the script code required to spend a P2WPKH output.
Since <code>dummy_utxo</code> is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.TxOut.html"><code>TxOut</code></a> type,
we can access the underlying public field <code>script_pubkey</code> which, in turn is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.Script.html"><code>Script</code></a> type.
We then use the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html#method.p2wpkh_script_code"><code>p2wpkh_script_code</code></a> method to generate the script code.</p>
<p>In <code>let input = TxIn {...}</code> we are instantiating the input for the transaction we are constructing
Inside the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.TxIn.html"><code>TxIn</code></a> struct we are setting the following fields:</p>
<ul>
<li><code>previous_output</code> is the outpoint of the dummy UTXO we are spending; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.OutPoint.html"><code>OutPoint</code></a> type.</li>
<li><code>script_sig</code> is the script code required to spend a P2WPKH output; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html"><code>ScriptBuf</code></a> type.
It should be empty. That's why the <code>ScriptBuf::new()</code>.</li>
<li><code>sequence</code> is the sequence number; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Sequence.html"><code>Sequence</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Sequence.html#associatedconstant.ENABLE_RBF_NO_LOCKTIME"><code>ENABLE_RBF_NO_LOCKTIME</code></a> constant.</li>
<li><code>witness</code> is the witness stack; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/witness/struct.Witness.html"><code>Witness</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/witness/struct.Witness.html#impl-Default"><code>default</code></a> method to create an empty witness that will be filled in later after signing.
This is possible because <code>Witness</code> implements the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait.</li>
</ul>
<p>In <code>let spend = TxOut {...}</code> we are instantiating the spend output.
Inside the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.TxOut.html"><code>TxOut</code></a> struct we are setting the following fields:</p>
<ul>
<li><code>value</code> is the amount we are spending; it is a <a href="https://doc.rust-lang.org/std/primitive.u64.html"><code>u64</code></a> type.
We are using the <code>const SPEND_AMOUNT</code> that we defined earlier.</li>
<li><code>script_pubkey</code> is the script code required to spend a P2WPKH output; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html"><code>ScriptBuf</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/address/struct.Address.html#method.script_pubkey"><code>script_pubkey</code></a> method to generate the script pubkey from the receivers address.
This will lock the output to the receiver's address.</li>
</ul>
<p>In <code>let change = TxOut {...}</code> we are instantiating the change output.
It is very similar to the <code>spend</code> output, but we are now using the <code>const CHANGE_AMOUNT</code> that we defined earlier<sup class="footnote-reference" id="fr-spend-1"><a href="#footnote-spend">5</a></sup>.
This is done by setting the <code>script_pubkey</code> field to <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html#method.new_p2wpkh"><code>ScriptBuf::new_p2wpkh(&amp;wpkh)</code></a>,
which generates P2WPKH-type of script pubkey.</p>
<p>In <code>let unsigned_tx = Transaction {...}</code> we are instantiating the transaction we want to sign and broadcast using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Transaction.html"><code>Transaction</code></a> struct.
We set the following fields:</p>
<ul>
<li><code>version</code> is the transaction version; it is a <a href="https://doc.rust-lang.org/std/primitive.u32.html"><code>i32</code></a> type.
We are using version <code>2</code> which means that <a href="https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki">BIP68</a> applies.</li>
<li><code>lock_time</code> is the transaction lock time;
it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/locktime/absolute/enum.LockTime.html"><code>LockTime</code></a> enum.
We are using the constant <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/locktime/absolute/enum.LockTime.html#associatedconstant.ZERO"><code>ZERO</code></a>
This will make the transaction valid immediately.</li>
<li><code>input</code> is the input vector; it is a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;TxIn&gt;</code></a> type.
We are using the <code>input</code> variable that we defined earlier wrapped in the <a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a> macro for convenient initialization.</li>
<li><code>output</code> is the output vector; it is a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;TxOut&gt;</code></a> type.
We are using the <code>spend</code> and <code>change</code> variables that we defined earlier wrapped in the <a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a> macro for convenient initialization.</li>
</ul>
<p>In <code>let mut sighash_cache = SighashCache::new(unsigned_tx);</code> we are instantiating a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/struct.SighashCache.html"><code>SighashCache</code></a> struct.
This is a type that efficiently calculates <a href="https://developer.bitcoin.org/devguide/transactions.html?highlight=sighash_all#signature-hash-types">signature hash message</a> for legacy, segwit and taproot inputs.
We are using the <code>new</code> method to instantiate the struct with the <code>unsigned_tx</code> that we defined earlier.
<code>new</code> takes any <code>Borrow&lt;Transaction&gt;</code> as an argument.
<a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow&lt;T&gt;</code></a> is a trait that allows us to pass either a reference to a <code>T</code> or a <code>T</code> itself.
Hence, you can pass a <code>Transaction</code> or a <code>&amp;Transaction</code> to <code>new</code>.</p>
<p><code>sighash_cache</code> is instantiated as mutable because we require a mutable reference when creating the sighash to sign using <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/struct.SighashCache.html#method.segwit_signature_hash"><code>segwit_signature_hash</code></a>.
This computes the <a href="https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki">BIP143</a> sighash for any flag type.
It takes the following arguments:</p>
<ul>
<li><code>input_index</code> is the index of the input we are signing; it is a <a href="https://doc.rust-lang.org/std/primitive.usize.html"><code>usize</code></a> type.
We are using <code>0</code> since we only have one input.</li>
<li><code>script_code</code> is the script code required to spend a P2WPKH output; it is a reference to <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.Script.html"><code>Script</code></a> type.
We are using the <code>script_code</code> variable that we defined earlier.</li>
<li><code>value</code> is the amount of the UTXO we are spending; it is a <a href="https://doc.rust-lang.org/std/primitive.u64.html"><code>u64</code></a> type.
We are using the <code>const DUMMY_UTXO_AMOUNT</code> that we defined earlier.</li>
<li><code>sighash_type</code> is the type of sighash; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/enum.EcdsaSighashType.html"><code>EcdsaSighashType</code></a> enum.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/enum.EcdsaSighashType.html#variant.All"><code>All</code></a> variant,
which indicates that the sighash will include all the inputs and outputs.</li>
</ul>
<p>We create the message <code>msg</code> by converting the <code>sighash</code> to a <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/struct.Message.html"><code>Message</code></a> type.
This is the message that we will sign.
The <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/struct.Message.html#impl-From%3C%26%27_%20bitcoin%3A%3Ahashes%3A%3Asha256d%3A%3AHash%3E">Message::from</a> method takes anything that implements the promises to be a thirty two byte hash i.e., 32 bytes that came from a cryptographically secure hashing algorithm.</p>
<p>We compute the signature <code>sig</code> by using the <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/struct.Secp256k1.html#method.sign_ecdsa"><code>sign_ecdsa</code></a> method.
It takes a reference to a <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/struct.Message.html"><code>Message</code></a> and a reference to a <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/struct.SecretKey.html"><code>SecretKey</code></a> as arguments,
and returns a <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/ecdsa/struct.Signature.html"><code>Signature</code></a> type.</p>
<p>In the next step, we update the witness stack for the input we just signed by first converting the <code>sighash_cache</code> into a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Transaction.html"><code>Transaction</code></a>
by using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/struct.SighashCache.html#method.into_transaction"><code>into_transaction</code></a> method.
We access the witness field of the first input with <code>tx.input[0].witness</code>.
It is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/witness/struct.Witness.html"><code>Witness</code></a> type.
We use the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/witness/struct.Witness.html#method.push_bitcoin_signature"><code>push_bitcoin_signature</code></a> method.
It expects two arguments:</p>
<ol>
<li>A reference to a <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/ecdsa/serialized_signature/struct.SerializedSignature.html"><code>SerializedSignature</code></a> type.
This is accomplished by calling the <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/ecdsa/struct.Signature.html#method.serialize_der"><code>serialize_der</code></a> method on the <code>Signature</code> <code>sig</code>,
which returns a <code>SerializedSignature</code> type.</li>
<li>A <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/enum.EcdsaSighashType.html"><code>EcdsaSighashType</code></a> enum.
Again we are using the same <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/enum.EcdsaSighashType.html#variant.All"><code>All</code></a> variant that we used earlier.</li>
</ol>
<p>We repeat the same step as above, but now using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/witness/struct.Witness.html#method.push"><code>push</code></a> method
to push the serialized public key to the witness stack.
It expects a single argument of type <code>AsRef&lt;[u8]&gt;</code> which is a reference to a byte slice.</p>
<p>As the last step we print this to terminal using the <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a> macro.
This transaction is now ready to be broadcast to the Bitcoin network.</p>
<!-- markdown-link-check-disable -->
<!-- markdown-link-check-enable -->
<hr>
<ol class="footnote-definition"><li id="footnote-today">
<p>mid-2023. <a href="#fr-today-1">↩</a></p>
</li>
<li id="footnote-change">
<p>Please note that the <code>CHANGE_AMOUNT</code> is not the same as the <code>DUMMY_UTXO_AMOUNT</code> minus the <code>SPEND_AMOUNT</code>.
This is due to the fact that we need to pay a fee for the transaction. <a href="#fr-change-1">↩</a></p>
</li>
<li id="footnote-expect">
<p>We will be unwrapping any <a href="https://doc.rust-lang.org/std/option"><code>Option&lt;T&gt;</code></a>/<a href="https://doc.rust-lang.org/std/result"><code>Result&lt;T, E&gt;</code></a>
with the <code>expect</code> method. <a href="#fr-expect-1">↩</a></p>
</li>
<li id="footnote-secp">
<p>Under the hood we are using the <a href="https://github.com/rust-bitcoin/rust-secp256k1/"><code>secp256k1</code></a> crate to generate the key pair.
<code>rust-secp256k1</code> is a wrapper around <a href="https://github.com/bitcoin-core/secp256k1">libsecp256k1</a>, a C
library implementing various cryptographic functions using the <a href="https://www.secg.org/">SECG</a> curve
<a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1</a>. <a href="#fr-secp-1">↩</a></p>
</li>
<li id="footnote-spend">
<p>And also we are locking the output to an address that we control: <a href="#fr-spend-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="constructing-and-signing-transactions---taproot"><a class="header" href="#constructing-and-signing-transactions---taproot">Constructing and Signing Transactions - Taproot</a></h1>
<p>In this section, we will construct a <a href="https://bitcoinops.org/en/topics/taproot/">Taproot transaction</a>.</p>
<p>This is the <code>cargo</code> commands that you need to run this example:</p>
<pre><code class="language-bash">cargo add bitcoin --features "std, rand-std"
</code></pre>
<p>First we'll need to import the following:</p>
<pre><code class="language-rust">use bitcoin::hashes::Hash;
use bitcoin::key::{Keypair, TapTweak, TweakedKeypair, UntweakedPublicKey};
use bitcoin::locktime::absolute;
use bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing, Verification};
use bitcoin::sighash::{Prevouts, SighashCache, TapSighashType};
use bitcoin::{
    transaction, Address, Amount, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut,
    Txid, Witness,
};</code></pre>
<p>Here is the logic behind these imports:</p>
<ul>
<li><code>bitcoin::key</code> is used to tweak keys according to <a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP340</a></li>
<li><code>bitcoin::hashes::Hash</code> is used to hash data</li>
<li><code>bitcoin::locktime::absolute</code> is used to create a locktime</li>
<li><code>bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing, Verification}</code> is used to sign transactions</li>
<li><code>use bitcoin::sighash::{Prevouts, SighashCache, TapSighashType}</code> is used to create and tweak taproot sighashes</li>
<li><code>bitcoin::{Address, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut, Txid, Witness}</code> is used to construct transactions</li>
</ul>
<p>Next, we define the following constants:</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::Amount;
</span>const DUMMY_UTXO_AMOUNT: Amount = Amount::from_sat(20_000_000);
const SPEND_AMOUNT: Amount = Amount::from_sat(5_000_000);
const CHANGE_AMOUNT: Amount = Amount::from_sat(14_999_000); // 1000 sat fee.</code></pre>
<ul>
<li><code>DUMMY_UTXO_AMOUNT</code> is the amount of the dummy UTXO we will be spending</li>
<li><code>SPEND_AMOUNT</code> is the amount we will be spending from the dummy UTXO</li>
<li><code>CHANGE_AMOUNT</code><sup class="footnote-reference" id="fr-change-1"><a href="#footnote-change">1</a></sup> is the amount we will be sending back to ourselves as change</li>
</ul>
<p>Before we can construct the transaction, we need to define some helper functions<sup class="footnote-reference" id="fr-expect-1"><a href="#footnote-expect">2</a></sup>:</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::secp256k1::{rand, Secp256k1, SecretKey, Signing};
</span><span class="boring">use bitcoin::key::Keypair;
</span>fn senders_keys&lt;C: Signing&gt;(secp: &amp;Secp256k1&lt;C&gt;) -&gt; Keypair {
    let sk = SecretKey::new(&amp;mut rand::thread_rng());
    Keypair::from_secret_key(secp, &amp;sk)
}</code></pre>
<p><code>senders_keys</code> generates a random private key and derives the corresponding public key hash.
This will be useful to mock a sender.
In a real application these would be actual secrets<sup class="footnote-reference" id="fr-secp-1"><a href="#footnote-secp">3</a></sup>.
We use the <code>SecretKey::new</code> method to generate a random private key <code>sk</code>.
We then use the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/key/struct.Keypair.html#method.from_secret_key"><code>Keypair::from_secret_key</code></a> method to instantiate a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/key/struct.Keypair.html"><code>Keypair</code></a> type,
which is a data structure that holds a keypair consisting of a secret and a public key.
Note that <code>senders_keys</code> is generic over the <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/trait.Signing.html"><code>Signing</code></a> trait.
This is used to indicate that is an instance of <code>Secp256k1</code> and can be used for signing.</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::{Address, Network};
</span>fn receivers_address() -&gt; Address {
    "bc1p0dq0tzg2r780hldthn5mrznmpxsxc0jux5f20fwj0z3wqxxk6fpqm7q0va".parse::&lt;Address&lt;_&gt;&gt;()
        .expect("a valid address")
        .require_network(Network::Bitcoin)
        .expect("valid address for mainnet")
}</code></pre>
<p><code>receivers_address</code> generates a receiver address.
In a real application this would be the address of the receiver.
We use the <code>parse</code> method on <code>&amp;str</code> to parse <code>"bc1p0dq0tzg2r780hldthn5mrznmpxsxc0jux5f20fwj0z3wqxxk6fpqm7q0va"</code><sup class="footnote-reference" id="fr-arbitrary_address-1"><a href="#footnote-arbitrary_address">4</a></sup> as an address.
Note that <code>bc1p0dq0tzg2r780hldthn5mrznmpxsxc0jux5f20fwj0z3wqxxk6fpqm7q0va</code> is a <a href="https://bitcoinops.org/en/topics/bech32/">Bech32</a> address.
This is an arbitrary, however valid, Bitcoin mainnet address.
Bitcoin applications are usually configured with specific Bitcoin network at the start and use that.
To prevent mistakes related to people sending satoshis to a wrong network we need to call the <code>require_network</code> method to ensure that the address is valid for the network, in our case mainnet.</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::{Amount, OutPoint, ScriptBuf, TxOut, Txid};
</span><span class="boring">use bitcoin::hashes::Hash;
</span><span class="boring">use bitcoin::key::UntweakedPublicKey;
</span><span class="boring">use bitcoin::locktime::absolute;
</span><span class="boring">use bitcoin::secp256k1::{Secp256k1, Verification};
</span><span class="boring">const DUMMY_UTXO_AMOUNT: Amount = Amount::from_sat(20_000_000);
</span>fn dummy_unspent_transaction_output&lt;C: Verification&gt;(
   secp: &amp;Secp256k1&lt;C&gt;,
   internal_key: UntweakedPublicKey,
) -&gt; (OutPoint, TxOut) {
    let script_pubkey = ScriptBuf::new_p2tr(secp, internal_key, None);

    let out_point = OutPoint {
        txid: Txid::all_zeros(), // Obviously invalid.
        vout: 0,
    };

    let utxo = TxOut { value: DUMMY_UTXO_AMOUNT, script_pubkey };

    (out_point, utxo)
}</code></pre>
<p><code>dummy_unspent_transaction_output</code> generates a dummy unspent transaction output (UTXO).
This is a P2TR (<code>ScriptBuf::new_p2tr</code>) UTXO.
It takes the following arguments:</p>
<ul>
<li><code>secp</code> is a reference to a <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/struct.Secp256k1.html"><code>Secp256k1</code></a> type.
This is used to verify the internal key.</li>
<li><code>internal_key</code> is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/key/type.UntweakedPublicKey.html"><code>UntweakedPublicKey</code></a> type.
This is the internal key that is used to generate the script pubkey.
It is untweaked, since we are not going to tweak the key.</li>
<li><code>merkle_root</code> is an optional <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/taproot/struct.TapNodeHash.html"><code>TapNodeHash</code></a> type.
This is the merkle root of the taproot tree.
Since we are not using a merkle tree, we are passing <code>None</code>.</li>
</ul>
<p><a href="https://docs.rs/bitcoin/0.32.0/bitcoin/key/trait.Verification.html"><code>Verification</code></a> is a trait that indicates that an instance of <code>Secp256k1</code> can be used for verification.
The UTXO has a dummy invalid transaction ID (<code>txid: Txid::all_zeros()</code>),
and a value of the <code>const DUMMY_UTXO_AMOUNT</code> that we defined earlier.
P2TR UTXOs could be tweaked (<a href="https://docs.rs/bitcoin/0.32.0/bitcoin/key/struct.TweakedPublicKey.html"><code>TweakedPublicKey</code></a>)
or untweaked (<a href="https://docs.rs/bitcoin/0.32.0/bitcoin/key/type.UntweakedPublicKey.html"><code>UntweakedPublicKey</code></a>).
We are using the latter, since we are not going to tweak the key.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.OutPoint.html"><code>OutPoint</code></a> struct to represent the previous transaction output.
Finally, we return the tuple <code>(out_point, utxo)</code>.</p>
<p>Now we are ready for our main function that will sign a transaction that spends a <code>p2tr</code> unspent output:</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::hashes::Hash;
</span><span class="boring">use bitcoin::key::{Keypair, TapTweak, TweakedKeypair, UntweakedPublicKey};
</span><span class="boring">use bitcoin::locktime::absolute;
</span><span class="boring">use bitcoin::secp256k1::{rand, Message, Secp256k1, SecretKey, Signing, Verification};
</span><span class="boring">use bitcoin::sighash::{Prevouts, SighashCache, TapSighashType};
</span><span class="boring">use bitcoin::{
</span><span class="boring">    transaction, Address, Amount, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut,
</span><span class="boring">    Txid, Witness,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const DUMMY_UTXO_AMOUNT: Amount = Amount::from_sat(20_000_000);
</span><span class="boring">const SPEND_AMOUNT: Amount = Amount::from_sat(5_000_000);
</span><span class="boring">const CHANGE_AMOUNT: Amount = Amount::from_sat(14_999_000); // 1000 sat fee.
</span><span class="boring">
</span><span class="boring">fn senders_keys&lt;C: Signing&gt;(secp: &amp;Secp256k1&lt;C&gt;) -&gt; Keypair {
</span><span class="boring">    let sk = SecretKey::new(&amp;mut rand::thread_rng());
</span><span class="boring">    Keypair::from_secret_key(secp, &amp;sk)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn receivers_address() -&gt; Address {
</span><span class="boring">    "bc1p0dq0tzg2r780hldthn5mrznmpxsxc0jux5f20fwj0z3wqxxk6fpqm7q0va".parse::&lt;Address&lt;_&gt;&gt;()
</span><span class="boring">        .expect("a valid address")
</span><span class="boring">        .require_network(Network::Bitcoin)
</span><span class="boring">        .expect("valid address for mainnet")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn dummy_unspent_transaction_output&lt;C: Verification&gt;(
</span><span class="boring">   secp: &amp;Secp256k1&lt;C&gt;,
</span><span class="boring">   internal_key: UntweakedPublicKey,
</span><span class="boring">) -&gt; (OutPoint, TxOut) {
</span><span class="boring">    let script_pubkey = ScriptBuf::new_p2tr(secp, internal_key, None);
</span><span class="boring">
</span><span class="boring">    let out_point = OutPoint {
</span><span class="boring">        txid: Txid::all_zeros(), // Obviously invalid.
</span><span class="boring">        vout: 0,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let utxo = TxOut { value: DUMMY_UTXO_AMOUNT, script_pubkey };
</span><span class="boring">
</span><span class="boring">    (out_point, utxo)
</span><span class="boring">}
</span>
fn main() {
    let secp = Secp256k1::new();

    // Get a keypair we control. In a real application these would come from a stored secret.
    let keypair = senders_keys(&amp;secp);
    let (internal_key, _parity) = keypair.x_only_public_key();

    // Get an unspent output that is locked to the key above that we control.
    // In a real application these would come from the chain.
    let (dummy_out_point, dummy_utxo) = dummy_unspent_transaction_output(&amp;secp, internal_key);

    // Get an address to send to.
    let address = receivers_address();

    // The input for the transaction we are constructing.
    let input = TxIn {
        previous_output: dummy_out_point, // The dummy output we are spending.
        script_sig: ScriptBuf::default(), // For a p2tr script_sig is empty.
        sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,
        witness: Witness::default(), // Filled in after signing.
    };

    // The spend output is locked to a key controlled by the receiver.
    let spend = TxOut { value: SPEND_AMOUNT, script_pubkey: address.script_pubkey() };

    // The change output is locked to a key controlled by us.
    let change = TxOut {
        value: CHANGE_AMOUNT,
        script_pubkey: ScriptBuf::new_p2tr(&amp;secp, internal_key, None), // Change comes back to us.
    };

    // The transaction we want to sign and broadcast.
    let mut unsigned_tx = Transaction {
        version: transaction::Version::TWO,  // Post BIP-68.
        lock_time: absolute::LockTime::ZERO, // Ignore the locktime.
        input: vec![input],                  // Input goes into index 0.
        output: vec![spend, change],         // Outputs, order does not matter.
    };
    let input_index = 0;

    // Get the sighash to sign.

    let sighash_type = TapSighashType::Default;
    let prevouts = vec![dummy_utxo];
    let prevouts = Prevouts::All(&amp;prevouts);

    let mut sighasher = SighashCache::new(&amp;mut unsigned_tx);
    let sighash = sighasher
        .taproot_key_spend_signature_hash(input_index, &amp;prevouts, sighash_type)
        .expect("failed to construct sighash");

    // Sign the sighash using the secp256k1 library (exported by rust-bitcoin).
    let tweaked: TweakedKeypair = keypair.tap_tweak(&amp;secp, None);
    let msg = Message::from_digest(sighash.to_byte_array());
    let signature = secp.sign_schnorr(&amp;msg, &amp;tweaked.to_inner());

    // Update the witness stack.
    let signature = bitcoin::taproot::Signature { signature, sighash_type };
    sighasher.witness_mut(input_index).unwrap().push(&amp;signature.to_vec());

    // Get the signed transaction.
    let tx = sighasher.into_transaction();

    // BOOM! Transaction signed and ready to broadcast.
    println!("{:#?}", tx);
}</code></pre>
<p>Let's go over the main function code block by block.</p>
<p><code>let secp = Secp256k1::new();</code> creates a new <code>Secp256k1</code> context with all capabilities.
Since we added the <code>rand-std</code> feature to our <code>Cargo.toml</code>,
we can use the <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/struct.Secp256k1.html#method.new"><code>SecretKey::new</code></a> method to generate a random private key <code>sk</code>.</p>
<p><code>let keypair = senders_keys(&amp;secp);</code> generates a keypair that we control,
and <code>let (internal_key, _parity) = keypair.x_only_public_key();</code> generates a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/key/struct.XOnlyPublicKey.html"><code>XOnlyPublicKey</code></a> that represent an X-only public key, used for verification of Schnorr signatures according to <a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP340</a>.
We won't be using second element from the returned tuple, the parity, so we are ignoring it by using the <code>_</code> underscore.
<code>let address = receivers_address();</code> generates a receiver's address <code>address</code>.
<code>let (dummy_out_point, dummy_utxo) = dummy_unspent_transaction_output(&amp;secp, internal_key);</code> generates a dummy unspent transaction output <code>dummy_utxo</code> and its corresponding outpoint <code>dummy_out_point</code>.
All of these are helper functions that we defined earlier.</p>
<p>In <code>let input = TxIn {...}</code> we are instantiating the input for the transaction we are constructing
Inside the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.TxIn.html"><code>TxIn</code></a> struct we are setting the following fields:</p>
<ul>
<li><code>previous_output</code> is the outpoint of the dummy UTXO we are spending; it has the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.OutPoint.html"><code>OutPoint</code></a> type.</li>
<li><code>script_sig</code> is the script code required to spend an output; it has the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html"><code>ScriptBuf</code></a> type.
We are instantiating a new empty script with <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html#method.new"><code>ScriptBuf::new()</code></a>.</li>
<li><code>sequence</code> is the sequence number; it has the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Sequence.html"><code>Sequence</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Sequence.html#associatedconstant.ENABLE_RBF_NO_LOCKTIME"><code>ENABLE_RBF_NO_LOCKTIME</code></a> constant.</li>
<li><code>witness</code> is the witness stack; has the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/witness/struct.Witness.html"><code>Witness</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/witness/struct.Witness.html#impl-Default"><code>default</code></a> method to create an empty witness that will be filled in later after signing.
This is possible because <code>Witness</code> implements the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait.</li>
</ul>
<p>In <code>let spend = TxOut {...}</code> we are instantiating the spend output.
Inside the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.TxOut.html"><code>TxOut</code></a> struct we are setting the following fields:</p>
<ul>
<li><code>value</code> is the amount we are assigning to be spendable by given <code>script_pubkey</code>; it has the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/struct.Amount.html"><code>Amount</code></a> type.
We are using the <code>const SPEND_AMOUNT</code> that we defined earlier.</li>
<li><code>script_pubkey</code> is the script code required to spend a P2TR output; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html"><code>ScriptBuf</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/address/struct.Address.html#method.script_pubkey"><code>script_pubkey</code></a> method to generate the script pubkey from the receivers address.
This will lock the output to the receiver's address.</li>
</ul>
<p>In <code>let change = TxOut {...}</code> we are instantiating the change output.
It is very similar to the <code>spend</code> output, but we are now using the <code>const CHANGE_AMOUNT</code> that we defined earlier<sup class="footnote-reference" id="fr-spend-1"><a href="#footnote-spend">5</a></sup>.
This is done by setting the <code>script_pubkey</code> field to <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html#method.new_p2tr"><code>ScriptBuf::new_p2tr(...)</code></a>,
which generates P2TR-type of script pubkey.</p>
<p>In <code>let unsigned_tx = Transaction {...}</code> we are instantiating the transaction we want to sign and broadcast using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Transaction.html"><code>Transaction</code></a> struct.
We set the following fields:</p>
<ul>
<li><code>version</code> is the transaction version; it has the <a href="https://docs.rs/bitcoin/0.32.2/bitcoin/blockdata/transaction/struct.Version.html"><code>transaction::Version</code></a> type.
We are using version <code>2</code> which means that <a href="https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki">BIP68</a> applies.</li>
<li><code>lock_time</code> is the transaction lock time;
it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/locktime/absolute/enum.LockTime.html"><code>LockTime</code></a> enum.
We are using the constant <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/locktime/absolute/enum.LockTime.html#associatedconstant.ZERO"><code>ZERO</code></a>
This will make the transaction valid immediately.</li>
<li><code>input</code> is the input vector; it is a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;TxIn&gt;</code></a> type.
We are using the <code>input</code> variable that we defined earlier wrapped in the <a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a> macro for convenient initialization.</li>
<li><code>output</code> is the output vector; it is a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;TxOut&gt;</code></a> type.
We are using the <code>spend</code> and <code>change</code> variables that we defined earlier wrapped in the <a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a> macro for convenient initialization.</li>
</ul>
<p>We need to reference the outputs of previous transactions in our transaction.
We accomplish this with the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/enum.Prevouts.html"><code>Prevouts</code></a> enum.
In <code>let prevouts = vec![dummy_utxo];</code>,
we create a vector of <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.TxOut.html"><code>TxOut</code></a> types that we want to reference.
In our case, we only have one output, the <code>dummy_utxo</code> that we defined earlier.
With <code>let prevouts = Prevouts::All(&amp;prevouts);</code> we create a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/enum.Prevouts.html#variant.All"><code>Prevouts::All</code></a> variant that takes a reference to a vector of <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.TxOut.html"><code>TxOut</code></a> types.</p>
<p>In <code>let mut sighash_cache = SighashCache::new(unsigned_tx);</code> we are instantiating a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/struct.SighashCache.html"><code>SighashCache</code></a> struct.
This is a type that efficiently calculates <a href="https://developer.bitcoin.org/devguide/transactions.html?highlight=sighash_all#signature-hash-types">signature hash message</a> for legacy, segwit and taproot inputs.
We are using the <code>new</code> method to instantiate the struct with the <code>unsigned_tx</code> that we defined earlier.
<code>new</code> takes any <code>Borrow&lt;Transaction&gt;</code> as an argument.
<a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow&lt;T&gt;</code></a> is a trait that allows us to pass either a reference to a <code>T</code> or a <code>T</code> itself.
Hence, you can pass a <code>Transaction</code>, a <code>&amp;Transaction</code> or a smart pointer to <code>new</code>.</p>
<p><code>sighash_cache</code> is bound as mutable because we are updating it with computed values during signing.
This is reflected by <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/struct.SighashCache.html#method.taproot_signature_hash"><code>taproot_signature_hash</code></a> taking a mutable reference.
This computes the <a href="https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki">BIP341</a> sighash for any flag type.
It takes the following arguments:</p>
<ul>
<li><code>input_index</code> is the index of the input we are signing; it has the <a href="https://doc.rust-lang.org/std/primitive.usize.html"><code>usize</code></a> type.
We are using <code>0</code> since we only have one input.</li>
<li><code>&amp;prevouts</code> is a reference to the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/enum.Prevouts.html"><code>Prevouts</code></a> enum that we defined earlier.
This is used to reference the outputs of previous transactions and also used to calculate our transaction value.</li>
<li><code>annex</code> is an optional argument that is used to pass the annex data.
We are not using it, so we are passing <code>None</code>.</li>
<li><code>leaf_hash_code_separator</code> is an optional argument that is used to pass the leaf hash code separator.
We are not using it, so we are passing <code>None</code>.</li>
<li><code>sighash_type</code> is the type of sighash; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/enum.TapSighashType.html"><code>TapSighashType</code></a> enum.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/enum.TapSighashType.html#variant.All"><code>All</code></a> variant,
which indicates that the sighash will include all the inputs and outputs.</li>
</ul>
<p>Since Taproot outputs contain the tweaked key and <code>keypair</code> represents untweaked (internal) key we have to tweak the key before signing using
<code>let tweaked: TweakedKeypair = keypair.tap_tweak(&amp;secp, None);</code>.</p>
<p>We create the message <code>msg</code> by converting the <code>sighash</code> to a <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/struct.Message.html"><code>Message</code></a> type.
This is a the message that we will sign.
The <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/struct.Message.html#impl-From%3C%26%27_%20bitcoin%3A%3Ahashes%3A%3Asha256d%3A%3AHash%3E">Message::from</a> method is available for types that are intended and safe for signing.</p>
<p>We compute the signature <code>sig</code> by using the <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/struct.Secp256k1.html#method.sign_schnorr"><code>sign_schnorr</code></a> method.
It takes a reference to a <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/struct.Message.html"><code>Message</code></a> and a reference to a <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/struct.Keypair.html"><code>Keypair</code></a> as arguments,
and returns a <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/ecdsa/struct.Signature.html"><code>Signature</code></a> type.</p>
<p>In the next step, we update the witness stack for the input we just signed by first releasing the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Transaction.html"><code>Transaction</code></a>
from <code>sighash_cache</code> by using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/sighash/struct.SighashCache.html#method.into_transaction"><code>into_transaction</code></a> method.
We access the witness field of the first input with <code>tx.input[0].witness</code>.
It is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/witness/struct.Witness.html"><code>Witness</code></a> type.
We use the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/witness/struct.Witness.html#method.push"><code>push</code></a> method
to push the serialized public and private Taproot keys.
It expects a single argument of type <code>AsRef&lt;[u8]&gt;</code> which is a reference to a byte slice.
We are using the <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>as_ref</code></a> method to convert the signature <code>sig</code> to a byte slice.</p>
<p>As the last step we print this to terminal using the <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a> macro.
This transaction is now ready to be broadcast to the Bitcoin network.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-change">
<p>Please note that the <code>CHANGE_AMOUNT</code> is not the same as the <code>DUMMY_UTXO_AMOUNT</code> minus the <code>SPEND_AMOUNT</code>.
This is due to the fact that we need to pay a fee for the transaction. <a href="#fr-change-1">↩</a></p>
</li>
<li id="footnote-expect">
<p>We will be unwrapping any <a href="https://doc.rust-lang.org/std/option"><code>Option&lt;T&gt;</code></a>/<a href="https://doc.rust-lang.org/std/result"><code>Result&lt;T, E&gt;</code></a>
with the <code>expect</code> method. <a href="#fr-expect-1">↩</a></p>
</li>
<li id="footnote-secp">
<p>Under the hood we are using the <a href="https://github.com/rust-bitcoin/rust-secp256k1/"><code>secp256k1</code></a> crate to generate the key pair.
<code>rust-secp256k1</code> is a wrapper around <a href="https://github.com/bitcoin-core/secp256k1">libsecp256k1</a>, a C
library implementing various cryptographic functions using the <a href="https://www.secg.org/">SECG</a> curve
<a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1</a>. <a href="#fr-secp-1">↩</a></p>
</li>
<li id="footnote-arbitrary_address">
<p>this is an arbitrary mainnet address from block 805222. <a href="#fr-arbitrary_address-1">↩</a></p>
</li>
<li id="footnote-spend">
<p>And also we are locking the output to an address that we control:
the <code>internal_key</code> public key hash that we generated earlier. <a href="#fr-spend-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-psbts"><a class="header" href="#working-with-psbts">Working with PSBTs</a></h1>
<p>The Partially Signed Bitcoin Transaction (PSBT) format specifies an encoding for partially signed transactions.
PSBTs are used in the context of multisignature wallets, hardware wallets,
and other use cases where multiple parties need to collaborate to sign a transaction.</p>
<p>PSBT version 0 is defined in <a href="https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki">BIP 174</a>.
It specifies 6 different roles that a party can play in the PSBT workflow:</p>
<ul>
<li><strong>Creator</strong>: Creates the PSBT and adds inputs and outputs.</li>
<li><strong>Updater</strong>: Adds additional information to the PSBT,
such as <code>redeemScript</code>, <code>witnessScript</code>, and BIP32 derivation paths.</li>
<li><strong>Signer</strong>: Signs the PSBT, either all inputs or a subset of them.</li>
<li><strong>Combiner</strong>: Combines multiple PSBTs into a single PSBT.</li>
<li><strong>Finalizer</strong>: Finalizes the PSBT,
adding any information necessary to complete the transaction.</li>
<li><strong>Extractor</strong>: Extracts the finalized transaction from the PSBT.</li>
</ul>
<p>Note that multiple roles can be handled by a single entity
but each role is specialized in what it should be capable of doing.</p>
<p>We provide the following examples:</p>
<ul>
<li><a href="psbt/multiple_inputs_segwit-v0.html">Constructing and Signing Multiple Inputs - SegWit V0</a></li>
<li><a href="psbt/multiple_inputs_taproot.html">Constructing and Signing Multiple Inputs - Taproot</a></li>
</ul>
<p>For extra information, see the <a href="https://bitcoinops.org/en/topics/psbt/">Bitcoin Optech article on PSBTs</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="psbts-constructing-and-signing-multiple-inputs---segwit-v0"><a class="header" href="#psbts-constructing-and-signing-multiple-inputs---segwit-v0">PSBTs: Constructing and Signing Multiple Inputs - SegWit V0</a></h1>
<p>The purpose of this section is to construct a PSBT that spends multiple inputs and signs it.
We'll cover the following <a href="https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki">BIP 174</a>
roles:</p>
<ul>
<li><strong>Creator</strong>: Creates a PSBT with multiple inputs and outputs.</li>
<li><strong>Updater</strong>: Adds Witness and SegWit V0 data to the PSBT.</li>
<li><strong>Signer</strong>: Signs the PSBT.</li>
<li><strong>Finalizer</strong>: Finalizes the PSBT.</li>
</ul>
<p>The example will focus on spending two SegWit V0 inputs:</p>
<ol>
<li>20,000,000 satoshi UTXO, the first receiving ("external") address.</li>
<li>10,000,000 satoshi UTXO, the first change ("internal") address.</li>
</ol>
<p>We'll be sending this to two outputs:</p>
<ol>
<li>25,000,000 satoshis to a receivers' address.</li>
<li>4,990,000 satoshis back to us as change.</li>
</ol>
<p>The miner's fee will be 10,000 satoshis.</p>
<p>This is the <code>cargo</code> commands that you need to run this example:</p>
<pre><code class="language-bash">cargo add bitcoin --features "std, rand-std"
</code></pre>
<p>First we'll need to import the following:</p>
<pre><code class="language-rust">use std::collections::BTreeMap;
use std::str::FromStr;

use bitcoin::bip32::{ChildNumber, Fingerprint, IntoDerivationPath as _, Xpriv, Xpub};
use bitcoin::hashes::Hash;
use bitcoin::locktime::absolute;
use bitcoin::secp256k1::{Secp256k1, Signing};
use bitcoin::{
    consensus, psbt, transaction, Address, Amount, EcdsaSighashType, Network, OutPoint, Psbt,
    ScriptBuf, Sequence, Transaction, TxIn, TxOut, Txid, WPubkeyHash, Witness,
};</code></pre>
<p>Here is the logic behind these imports:</p>
<ul>
<li><code>std::collections::BTreeMap</code> is used to store the key-value pairs of the Public Key PSBT input fields.</li>
<li><code>std::str::FromStr</code> is used to parse strings into Bitcoin primitives</li>
<li><code>bitcoin::bip32</code> is used to derive keys according to <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32</a></li>
<li><code>bitcoin::hashes::Hash</code> is used to hash data</li>
<li><code>bitcoin::locktime::absolute</code> is used to create a locktime</li>
<li><code>bitcoin::secp256k1</code> is used to sign transactions</li>
<li><code>bitcoin::consensus</code> is used to serialize the final signed transaction to a raw transaction</li>
<li><code>bitcoin::psbt</code> is used to construct and manipulate PSBTs</li>
<li><code>bitcoin::transaction</code> and <code>bitcoin::{Address, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut, Txid, Witness}</code> are used to construct transactions</li>
<li><code>bitcoin::WPubkeyHash</code> is used to construct SegWit V0 inputs</li>
</ul>
<p>Next, we define the following constants:</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::Amount;
</span>const XPRIV: &amp;str = "xprv9tuogRdb5YTgcL3P8Waj7REqDuQx4sXcodQaWTtEVFEp6yRKh1CjrWfXChnhgHeLDuXxo2auDZegMiVMGGxwxcrb2PmiGyCngLxvLeGsZRq";
const BIP84_DERIVATION_PATH: &amp;str = "m/84'/0'/0'";
const MASTER_FINGERPRINT: &amp;str = "9680603f";
const DUMMY_UTXO_AMOUNT_INPUT_1: Amount = Amount::from_sat(20_000_000);
const DUMMY_UTXO_AMOUNT_INPUT_2: Amount = Amount::from_sat(10_000_000);
const SPEND_AMOUNT: Amount = Amount::from_sat(25_000_000);
const CHANGE_AMOUNT: Amount = Amount::from_sat(4_990_000); // 10_000 sat fee.</code></pre>
<ul>
<li><code>XPRIV</code> is the extended private key that will be used to derive the keys for the SegWit V0 inputs.</li>
<li><code>MASTER_FINGERPRINT</code> is the fingerprint of the master key.</li>
<li><code>BIP84_DERIVATION_PATH</code> is the derivation path for the BIP 84 key.
Since this is a mainnet example, we are using the path <code>m/84'/0'/0'</code>.</li>
<li><code>DUMMY_UTXO_AMOUNT_INPUT_1</code> is the amount of the dummy UTXO we will be spending from the first input.</li>
<li><code>DUMMY_UTXO_AMOUNT_INPUT_2</code> is the amount of the dummy UTXO we will be spending from the second input.</li>
<li><code>SPEND_AMOUNT</code> is the amount we will be spending from the dummy UTXO related to the first input.</li>
<li><code>CHANGE_AMOUNT</code><sup class="footnote-reference" id="fr-change-1"><a href="#footnote-change">1</a></sup> is the amount we will be sending back to ourselves as change.</li>
</ul>
<p>Before we can construct the transaction, we need to define some helper functions:</p>
<pre><code class="language-rust"><span class="boring">use std::collections::BTreeMap;
</span><span class="boring">use std::str::FromStr;
</span><span class="boring">
</span><span class="boring">use bitcoin::bip32::{ChildNumber, IntoDerivationPath, Fingerprint, Xpriv, Xpub};
</span><span class="boring">use bitcoin::hashes::Hash;
</span><span class="boring">use bitcoin::secp256k1::{Secp256k1, Signing};
</span><span class="boring">use bitcoin::{Address, Amount, Network, OutPoint, Txid, TxOut};
</span><span class="boring">
</span><span class="boring">const BIP84_DERIVATION_PATH: &amp;str = "m/84'/0'/0'";
</span><span class="boring">const DUMMY_UTXO_AMOUNT_INPUT_1: Amount = Amount::from_sat(20_000_000);
</span><span class="boring">const DUMMY_UTXO_AMOUNT_INPUT_2: Amount = Amount::from_sat(10_000_000);
</span>fn get_external_address_xpriv&lt;C: Signing&gt;(
    secp: &amp;Secp256k1&lt;C&gt;,
    master_xpriv: Xpriv,
    index: u32,
) -&gt; Xpriv {
    let derivation_path =
        BIP84_DERIVATION_PATH.into_derivation_path().expect("valid derivation path");
    let child_xpriv = master_xpriv
        .derive_priv(secp, &amp;derivation_path)
        .expect("valid child xpriv");
    let external_index = ChildNumber::from_normal_idx(0).unwrap();
    let idx = ChildNumber::from_normal_idx(index).expect("valid index number");

    child_xpriv
        .derive_priv(secp, &amp;[external_index, idx])
        .expect("valid xpriv")
}

fn get_internal_address_xpriv&lt;C: Signing&gt;(
    secp: &amp;Secp256k1&lt;C&gt;,
    master_xpriv: Xpriv,
    index: u32,
) -&gt; Xpriv {
    let derivation_path =
        BIP84_DERIVATION_PATH.into_derivation_path().expect("valid derivation path");
    let child_xpriv = master_xpriv
        .derive_priv(secp, &amp;derivation_path)
        .expect("valid child xpriv");
    let internal_index = ChildNumber::from_normal_idx(1).unwrap();
    let idx = ChildNumber::from_normal_idx(index).expect("valid index number");

    child_xpriv
        .derive_priv(secp, &amp;[internal_index, idx])
        .expect("valid xpriv")
}

fn receivers_address() -&gt; Address {
    Address::from_str("bc1q7cyrfmck2ffu2ud3rn5l5a8yv6f0chkp0zpemf")
        .expect("a valid address")
        .require_network(Network::Bitcoin)
        .expect("valid address for mainnet")
}

fn dummy_unspent_transaction_outputs() -&gt; Vec&lt;(OutPoint, TxOut)&gt; {
    let script_pubkey_1 = Address::from_str("bc1qrwuu3ydv0jfza4a0ehtfd03m9l4vw3fy0hfm50")
        .expect("a valid address")
        .require_network(Network::Bitcoin)
        .expect("valid address for mainnet")
        .script_pubkey();

    let out_point_1 = OutPoint {
        txid: Txid::all_zeros(), // Obviously invalid.
        vout: 0,
    };

    let utxo_1 = TxOut {
        value: DUMMY_UTXO_AMOUNT_INPUT_1,
        script_pubkey: script_pubkey_1,
    };

    let script_pubkey_2 = Address::from_str("bc1qy7swwpejlw7a2rp774pa8rymh8tw3xvd2x2xkd")
        .expect("a valid address")
        .require_network(Network::Bitcoin)
        .expect("valid address for mainnet")
        .script_pubkey();

    let out_point_2 = OutPoint {
        txid: Txid::all_zeros(), // Obviously invalid.
        vout: 1,
    };

    let utxo_2 = TxOut {
        value: DUMMY_UTXO_AMOUNT_INPUT_2,
        script_pubkey: script_pubkey_2,
    };
    vec![(out_point_1, utxo_1), (out_point_2, utxo_2)]
}</code></pre>
<p><code>get_external_address_xpriv</code> and <code>get_internal_address_xpriv</code> generates the external and internal addresses extended private key,
given a master extended private key and an address index; respectively.
Note that these functions takes a <code>Secp256k1</code> that is
generic over the <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/trait.Signing.html"><code>Signing</code></a> trait.
This is used to indicate that is an instance of <code>Secp256k1</code> and can be used for signing and other things.</p>
<p><code>receivers_address</code> generates a receiver address.
In a real application this would be the address of the receiver.
We use the method <code>Address::from_str</code> to parse the string of addresses<sup class="footnote-reference" id="fr-arbitrary_address-1"><a href="#footnote-arbitrary_address">2</a></sup> into an <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/struct.Address.html"><code>Address</code></a>.
Hence, it is necessary to import the <code>std::str::FromStr</code> trait.
This is an arbitrary, however valid, Bitcoin mainnet address.
Hence we use the <code>require_network</code> method to ensure that the address is valid for mainnet.</p>
<p><code>dummy_unspent_transaction_outputs</code> generates a dummy unspent transaction output (UTXO).
This is a P2WPKH (<code>ScriptBuf::new_p2wpkh</code>) UTXO.</p>
<p>The UTXO has a dummy invalid transaction ID (<code>txid: Txid::all_zeros()</code>),
and any value of the <code>const DUMMY_UTXO_AMOUNT_N</code> that we defined earlier.
Note that the <code>vout</code> is set to <code>0</code> for the first UTXO and <code>1</code> for the second UTXO.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.OutPoint.html"><code>OutPoint</code></a> struct to represent the transaction output.
Finally, we return vector of tuples <code>(out_point, utxo)</code>.</p>
<p>Now we are ready for our main function that will create, update, and sign a PSBT;
while also extracting a transaction that spends the <code>p2wpkh</code>s unspent outputs:</p>
<pre><code class="language-rust"><span class="boring">use std::collections::BTreeMap;
</span><span class="boring">use std::str::FromStr;
</span><span class="boring">
</span><span class="boring">use bitcoin::bip32::{ChildNumber, Fingerprint, IntoDerivationPath as _, Xpriv, Xpub};
</span><span class="boring">use bitcoin::hashes::Hash;
</span><span class="boring">use bitcoin::locktime::absolute;
</span><span class="boring">use bitcoin::secp256k1::{Secp256k1, Signing};
</span><span class="boring">use bitcoin::{
</span><span class="boring">    consensus, psbt, transaction, Address, Amount, EcdsaSighashType, Network, OutPoint, Psbt,
</span><span class="boring">    ScriptBuf, Sequence, Transaction, TxIn, TxOut, Txid, WPubkeyHash, Witness,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const XPRIV: &amp;str = "xprv9tuogRdb5YTgcL3P8Waj7REqDuQx4sXcodQaWTtEVFEp6yRKh1CjrWfXChnhgHeLDuXxo2auDZegMiVMGGxwxcrb2PmiGyCngLxvLeGsZRq";
</span><span class="boring">const BIP84_DERIVATION_PATH: &amp;str = "m/84'/0'/0'";
</span><span class="boring">const MASTER_FINGERPRINT: &amp;str = "9680603f";
</span><span class="boring">const DUMMY_UTXO_AMOUNT_INPUT_1: Amount = Amount::from_sat(20_000_000);
</span><span class="boring">const DUMMY_UTXO_AMOUNT_INPUT_2: Amount = Amount::from_sat(10_000_000);
</span><span class="boring">const SPEND_AMOUNT: Amount = Amount::from_sat(25_000_000);
</span><span class="boring">const CHANGE_AMOUNT: Amount = Amount::from_sat(4_990_000); // 10_000 sat fee.
</span><span class="boring">
</span><span class="boring">fn get_external_address_xpriv&lt;C: Signing&gt;(
</span><span class="boring">    secp: &amp;Secp256k1&lt;C&gt;,
</span><span class="boring">    master_xpriv: Xpriv,
</span><span class="boring">    index: u32,
</span><span class="boring">) -&gt; Xpriv {
</span><span class="boring">    let derivation_path =
</span><span class="boring">        BIP84_DERIVATION_PATH.into_derivation_path().expect("valid derivation path");
</span><span class="boring">    let child_xpriv = master_xpriv
</span><span class="boring">        .derive_priv(secp, &amp;derivation_path)
</span><span class="boring">        .expect("valid child xpriv");
</span><span class="boring">    let external_index = ChildNumber::from_normal_idx(0).unwrap();
</span><span class="boring">    let idx = ChildNumber::from_normal_idx(index).expect("valid index number");
</span><span class="boring">
</span><span class="boring">    child_xpriv
</span><span class="boring">        .derive_priv(secp, &amp;[external_index, idx])
</span><span class="boring">        .expect("valid xpriv")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_internal_address_xpriv&lt;C: Signing&gt;(
</span><span class="boring">    secp: &amp;Secp256k1&lt;C&gt;,
</span><span class="boring">    master_xpriv: Xpriv,
</span><span class="boring">    index: u32,
</span><span class="boring">) -&gt; Xpriv {
</span><span class="boring">    let derivation_path =
</span><span class="boring">        BIP84_DERIVATION_PATH.into_derivation_path().expect("valid derivation path");
</span><span class="boring">    let child_xpriv = master_xpriv
</span><span class="boring">        .derive_priv(secp, &amp;derivation_path)
</span><span class="boring">        .expect("valid child xpriv");
</span><span class="boring">    let internal_index = ChildNumber::from_normal_idx(1).unwrap();
</span><span class="boring">    let idx = ChildNumber::from_normal_idx(index).expect("valid index number");
</span><span class="boring">
</span><span class="boring">    child_xpriv
</span><span class="boring">        .derive_priv(secp, &amp;[internal_index, idx])
</span><span class="boring">        .expect("valid xpriv")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn receivers_address() -&gt; Address {
</span><span class="boring">    Address::from_str("bc1q7cyrfmck2ffu2ud3rn5l5a8yv6f0chkp0zpemf")
</span><span class="boring">        .expect("a valid address")
</span><span class="boring">        .require_network(Network::Bitcoin)
</span><span class="boring">        .expect("valid address for mainnet")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn dummy_unspent_transaction_outputs() -&gt; Vec&lt;(OutPoint, TxOut)&gt; {
</span><span class="boring">    let script_pubkey_1 = Address::from_str("bc1qrwuu3ydv0jfza4a0ehtfd03m9l4vw3fy0hfm50")
</span><span class="boring">        .expect("a valid address")
</span><span class="boring">        .require_network(Network::Bitcoin)
</span><span class="boring">        .expect("valid address for mainnet")
</span><span class="boring">        .script_pubkey();
</span><span class="boring">
</span><span class="boring">    let out_point_1 = OutPoint {
</span><span class="boring">        txid: Txid::all_zeros(), // Obviously invalid.
</span><span class="boring">        vout: 0,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let utxo_1 = TxOut {
</span><span class="boring">        value: DUMMY_UTXO_AMOUNT_INPUT_1,
</span><span class="boring">        script_pubkey: script_pubkey_1,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let script_pubkey_2 = Address::from_str("bc1qy7swwpejlw7a2rp774pa8rymh8tw3xvd2x2xkd")
</span><span class="boring">        .expect("a valid address")
</span><span class="boring">        .require_network(Network::Bitcoin)
</span><span class="boring">        .expect("valid address for mainnet")
</span><span class="boring">        .script_pubkey();
</span><span class="boring">
</span><span class="boring">    let out_point_2 = OutPoint {
</span><span class="boring">        txid: Txid::all_zeros(), // Obviously invalid.
</span><span class="boring">        vout: 1,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let utxo_2 = TxOut {
</span><span class="boring">        value: DUMMY_UTXO_AMOUNT_INPUT_2,
</span><span class="boring">        script_pubkey: script_pubkey_2,
</span><span class="boring">    };
</span><span class="boring">    vec![(out_point_1, utxo_1), (out_point_2, utxo_2)]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let secp = Secp256k1::new();

    // Get the individual xprivs we control. In a real application these would come from a stored secret.
    let master_xpriv = XPRIV.parse::&lt;Xpriv&gt;().expect("valid xpriv");
    let xpriv_input_1 = get_external_address_xpriv(&amp;secp, master_xpriv, 0);
    let xpriv_input_2 = get_internal_address_xpriv(&amp;secp, master_xpriv, 0);
    let xpriv_change = get_internal_address_xpriv(&amp;secp, master_xpriv, 1);

    // Get the PKs
    let pk_input_1 = Xpub::from_priv(&amp;secp, &amp;xpriv_input_1).to_pub();
    let pk_input_2 = Xpub::from_priv(&amp;secp, &amp;xpriv_input_2).to_pub();
    let pk_inputs = [pk_input_1, pk_input_2];
    let pk_change = Xpub::from_priv(&amp;secp, &amp;xpriv_change).to_pub();

    // Get the Witness Public Key Hashes (WPKHs)
    let wpkhs: Vec&lt;WPubkeyHash&gt; = pk_inputs.iter().map(|pk| pk.wpubkey_hash()).collect();

    // Get the unspent outputs that are locked to the key above that we control.
    // In a real application these would come from the chain.
    let utxos: Vec&lt;TxOut&gt; = dummy_unspent_transaction_outputs()
        .into_iter()
        .map(|(_, utxo)| utxo)
        .collect();

    // Get the addresses to send to.
    let address = receivers_address();

    // The inputs for the transaction we are constructing.
    let inputs: Vec&lt;TxIn&gt; = dummy_unspent_transaction_outputs()
        .into_iter()
        .map(|(outpoint, _)| TxIn {
            previous_output: outpoint,
            script_sig: ScriptBuf::default(),
            sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,
            witness: Witness::default(),
        })
        .collect();

    // The spend output is locked to a key controlled by the receiver.
    let spend = TxOut {
        value: SPEND_AMOUNT,
        script_pubkey: address.script_pubkey(),
    };

    // The change output is locked to a key controlled by us.
    let change = TxOut {
        value: CHANGE_AMOUNT,
        script_pubkey: ScriptBuf::new_p2wpkh(&amp;pk_change.wpubkey_hash()), // Change comes back to us.
    };

    // The transaction we want to sign and broadcast.
    let unsigned_tx = Transaction {
        version: transaction::Version::TWO,  // Post BIP 68.
        lock_time: absolute::LockTime::ZERO, // Ignore the locktime.
        input: inputs,                       // Input is 0-indexed.
        output: vec![spend, change],         // Outputs, order does not matter.
    };

    // Now we'll start the PSBT workflow.
    // Step 1: Creator role; that creates,
    // and add inputs and outputs to the PSBT.
    let mut psbt = Psbt::from_unsigned_tx(unsigned_tx).expect("Could not create PSBT");

    // Step 2:Updater role; that adds additional
    // information to the PSBT.
    let ty = EcdsaSighashType::All.into();
    let derivation_paths = [
        "m/84'/0'/0'/0/0".into_derivation_path().expect("valid derivation path"), // First external address.
        "m/84'/0'/0'/1/0".into_derivation_path().expect("valid derivation path"), // First internal address.
    ];
    let mut bip32_derivations = Vec::new();
    for (idx, pk) in pk_inputs.iter().enumerate() {
        let mut map = BTreeMap::new();
        let fingerprint = Fingerprint::from_str(MASTER_FINGERPRINT).expect("valid fingerprint");
        map.insert(pk.0, (fingerprint, derivation_paths[idx].clone()));
        bip32_derivations.push(map);
    }
    psbt.inputs = vec![
        psbt::Input {
            witness_utxo: Some(utxos[0].clone()),
            redeem_script: Some(ScriptBuf::new_p2wpkh(&amp;wpkhs[0])),
            bip32_derivation: bip32_derivations[0].clone(),
            sighash_type: Some(ty),
            ..Default::default()
        },
        psbt::Input {
            witness_utxo: Some(utxos[1].clone()),
            redeem_script: Some(ScriptBuf::new_p2wpkh(&amp;wpkhs[1])),
            bip32_derivation: bip32_derivations[1].clone(),
            sighash_type: Some(ty),
            ..Default::default()
        },
    ];

    // Step 3: Signer role; that signs the PSBT.
    psbt.sign(&amp;master_xpriv, &amp;secp).expect("valid signature");

    // Step 4: Finalizer role; that finalizes the PSBT.
    println!("PSBT Inputs: {:#?}", psbt.inputs);
    let final_script_witness: Vec&lt;_&gt; = psbt
        .inputs
        .iter()
        .enumerate()
        .map(|(idx, input)| {
            let (_, sig) = input.partial_sigs.iter().next().expect("we have one sig");
            Witness::p2wpkh(sig, &amp;pk_inputs[idx].0)
        })
        .collect();
    psbt.inputs.iter_mut().enumerate().for_each(|(idx, input)| {
        // Clear all the data fields as per the spec.
        input.final_script_witness = Some(final_script_witness[idx].clone());
        input.partial_sigs = BTreeMap::new();
        input.sighash_type = None;
        input.redeem_script = None;
        input.witness_script = None;
        input.bip32_derivation = BTreeMap::new();
    });

    // BOOM! Transaction signed and ready to broadcast.
    let signed_tx = psbt.extract_tx().expect("valid transaction");
    let serialized_signed_tx = consensus::encode::serialize_hex(&amp;signed_tx);
    println!("Transaction Details: {:#?}", signed_tx);
    // check with:
    // bitcoin-cli decoderawtransaction &lt;RAW_TX&gt; true
    println!("Raw Transaction: {}", serialized_signed_tx);
}</code></pre>
<p>Let's go over the main function code block by block.</p>
<p><code>let secp = Secp256k1::new();</code> creates a new <code>Secp256k1</code> context with all capabilities.
Since we added the <code>rand-std</code> feature to our <code>Cargo.toml</code>,</p>
<p>Next, we get the individual extended private keys (xpriv) that we control.
These are:</p>
<ul>
<li>the master xpriv,</li>
<li>the xprivs for inputs 1 and 2;
these are done with the <code>get_external_address_xpriv</code> and <code>get_internal_address_xpriv</code> functions.</li>
<li>the xpriv for the change output, also using the <code>get_internal_address_xpriv</code> function.</li>
</ul>
<p>The inputs for the transaction we are constructing,
here named <code>utxos</code>,
are created with the <code>dummy_unspent_transaction_outputs</code> function.
<code>let address = receivers_address();</code> generates a receiver's address <code>address</code>.
All of these are helper functions that we defined earlier.</p>
<p>In <code>let input = TxIn {...}</code> we are instantiating the inputs for the transaction we are constructing
Inside the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.TxIn.html"><code>TxIn</code></a> struct we are setting the following fields:</p>
<ul>
<li><code>previous_output</code> is the outpoint of the dummy UTXO we are spending; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.OutPoint.html"><code>OutPoint</code></a> type.</li>
<li><code>script_sig</code> is the script code required to spend an output; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html"><code>ScriptBuf</code></a> type.
We are instantiating a new empty script with <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html#method.new"><code>ScriptBuf::new()</code></a>.</li>
<li><code>sequence</code> is the sequence number; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Sequence.html"><code>Sequence</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Sequence.html#associatedconstant.ENABLE_RBF_NO_LOCKTIME"><code>ENABLE_RBF_NO_LOCKTIME</code></a> constant.</li>
<li><code>witness</code> is the witness stack; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/witness/struct.Witness.html"><code>Witness</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/witness/struct.Witness.html#impl-Default"><code>default</code></a> method to create an empty witness that will be filled in later after signing.
This is possible because <code>Witness</code> implements the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait.</li>
</ul>
<p>In <code>let spend = TxOut {...}</code> we are instantiating the spend output.
Inside the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.TxOut.html"><code>TxOut</code></a> struct we are setting the following fields:</p>
<ul>
<li><code>value</code> is the amount we are spending; it is a <a href="https://doc.rust-lang.org/std/primitive.u64.html"><code>u64</code></a> type.
We are using the <code>const SPEND_AMOUNT</code> that we defined earlier.</li>
<li><code>script_pubkey</code> is the script code required to spend a P2WPKH output; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html"><code>ScriptBuf</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/address/struct.Address.html#method.script_pubkey"><code>script_pubkey</code></a> method to generate the script pubkey from the receivers address.
This will lock the output to the receiver's address.</li>
</ul>
<p>In <code>let change = TxOut {...}</code> we are instantiating the change output.
It is very similar to the <code>spend</code> output, but we are now using the <code>const CHANGE_AMOUNT</code> that we defined earlier<sup class="footnote-reference" id="fr-spend-1"><a href="#footnote-spend">3</a></sup>.
This is done by setting the <code>script_pubkey</code> field to <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html#method.new_p2wpkh"><code>ScriptBuf::new_p2wpkh(...)</code></a>,
which generates P2WPKH-type of script pubkey.</p>
<p>In <code>let unsigned_tx = Transaction {...}</code> we are instantiating the transaction we want to sign and broadcast using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Transaction.html"><code>Transaction</code></a> struct.
We set the following fields:</p>
<ul>
<li><code>version</code> is the transaction version; it can be a <a href="https://doc.rust-lang.org/std/primitive.u32.html"><code>i32</code></a> type.
However it is best to use the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/block/struct.Version.html"><code>Version</code></a> struct.
We are using version <code>TWO</code> which means that <a href="https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki">BIP 68</a> applies.</li>
<li><code>lock_time</code> is the transaction lock time;
it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/locktime/absolute/enum.LockTime.html"><code>LockTime</code></a> enum.
We are using the constant <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/locktime/absolute/enum.LockTime.html#associatedconstant.ZERO"><code>ZERO</code></a>
This will make the transaction valid immediately.</li>
<li><code>input</code> is the input vector; it is a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;TxIn&gt;</code></a> type.
We are using the <code>input</code> variable that we defined earlier wrapped in the <a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a> macro for convenient initialization.</li>
<li><code>output</code> is the output vector; it is a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;TxOut&gt;</code></a> type.
We are using the <code>spend</code> and <code>change</code> variables that we defined earlier wrapped in the <a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a> macro for convenient initialization.</li>
</ul>
<p>Now we are ready to start our PSBT workflow.</p>
<p>The first step is the Creator role.
We create a PSBT from the unsigned transaction using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/psbt/struct.Psbt.html#method.from_unsigned_tx"><code>Psbt::from_unsigned_tx</code></a> method.</p>
<p>Next, we move to the Updater role.
We add additional information to the PSBT.
This is done by setting the <code>psbt.inputs</code> field to a vector of <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/psbt/struct.Input.html"><code>Input</code></a> structs.
In particular, we set the following fields:</p>
<ul>
<li><code>witness_utxo</code> is the witness UTXO; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;TxOut&gt;</code></a> type.
We are using the <code>utxos</code> vector that we defined earlier.</li>
<li><code>redeem_script</code> is the redeem script; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;ScriptBuf&gt;</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html#method.new_p2wpkh"><code>ScriptBuf::new_p2wpkh</code></a> method to create a P2WPKH script.</li>
<li><code>bip32_derivation</code> is the BIP 32 derivation; it is a <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap&lt;Xpub, (Fingerprint, DerivationPath)&gt;</code></a> type.
We are using a vector of <code>BTreeMap</code>s.</li>
<li><code>sighash_type</code> is the sighash type; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;PsbtSighashType&gt;</code></a> type.</li>
</ul>
<p>All the other fields are set to their default values using the <a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default"><code>Default::default()</code></a> method.</p>
<p>The following step is the Signer role.
Here is were we sign the PSBT with the
<a href="https://docs.rs/bitcoin/0.32.0/bitcoin/psbt/struct.Psbt.html#method.sign"><code>sign</code></a> method.
This method takes the master extended private key and the <code>Secp256k1</code> context as arguments.
It attempts to create all the required signatures for this PSBT using the extended private key.</p>
<p>Finally, we move to the Finalizer role.
Here we finalize the PSBT, making it ready to be extracted into a signed transaction,
and if necessary, broadcasted to the Bitcoin network.
This is done by setting the following fields:</p>
<ul>
<li><code>final_script_witness</code> is the final script witness; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;Witness&gt;</code></a> type.
We are using the <code>Witness::p2wpkh()</code> method to create a witness required to spend a P2WPKH output.</li>
<li><code>partial_sigs</code> is the partial signatures; it is a <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap&lt;XOnlyPublicKey, Vec&lt;u8&gt;&gt;</code></a> type.
We are using an empty map.</li>
<li><code>sighash_type</code> is the sighash type; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;PsbtSighashType&gt;</code></a> type.
We are using the <code>None</code> value.</li>
<li><code>redeem_script</code> is the redeem script; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;ScriptBuf&gt;</code></a> type.
We are using the <code>None</code> value.</li>
<li><code>witness_script</code> is the witness script; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;ScriptBuf&gt;</code></a> type.</li>
<li><code>bip32_derivation</code> is the BIP 32 derivation; it is a <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap&lt;Xpub, (Fingerprint, DerivationPath)&gt;</code></a> type.
We are using an empty map.</li>
</ul>
<p>Finally, we extract the signed transaction from the PSBT using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/psbt/struct.Psbt.html#method.extract_tx"><code>extract_tx</code></a> method.</p>
<p>As the last step we print both the transaction details and the raw transaction
to the terminal using the <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a> macro.
This transaction is now ready to be broadcast to the Bitcoin network.</p>
<p>For anything in production, the step 4 (Finalizer) should be done with the
<a href="https://docs.rs/miniscript/11.0.0/miniscript/psbt/trait.PsbtExt.html"><code>psbt::PsbtExt</code> from the <code>miniscript</code> crate</a> trait.
It provides a
<a href="https://docs.rs/miniscript/11.0.0/miniscript/psbt/trait.PsbtExt.html#tymethod.finalize_mut"><code>.finalize_mut</code></a>
to a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/psbt/struct.Psbt.html"><code>Psbt</code></a> object,
which takes in a mutable reference to <code>Psbt</code> and populates the <code>final_witness</code> and <code>final_scriptsig</code> for all inputs.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-change">
<p>Please note that the <code>CHANGE_AMOUNT</code> is not the same as the <code>DUMMY_UTXO_AMOUNT_INPUT_N</code>s minus the <code>SPEND_AMOUNT</code>.
This is due to the fact that we need to pay a miner's fee for the transaction. <a href="#fr-change-1">↩</a></p>
</li>
<li id="footnote-arbitrary_address">
<p>this is an arbitrary mainnet addresses from block 805222. <a href="#fr-arbitrary_address-1">↩</a></p>
</li>
<li id="footnote-spend">
<p>And also we are locking the output to an address that we control:
the <code>wpkh</code> public key hash that we generated earlier. <a href="#fr-spend-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="psbts-constructing-and-signing-multiple-inputs---taproot"><a class="header" href="#psbts-constructing-and-signing-multiple-inputs---taproot">PSBTs: Constructing and Signing Multiple Inputs - Taproot</a></h1>
<p>The purpose of this section is to construct a PSBT that spends multiple inputs and signs it.
We'll cover the following <a href="https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki">BIP 174</a>
roles:</p>
<ul>
<li><strong>Creator</strong>: Creates a PSBT with multiple inputs and outputs.</li>
<li><strong>Updater</strong>: Adds Witness and Taproot data to the PSBT.</li>
<li><strong>Signer</strong>: Signs the PSBT.</li>
<li><strong>Finalizer</strong>: Finalizes the PSBT.</li>
</ul>
<p>The example will focus on spending two Taproot inputs:</p>
<ol>
<li>20,000,000 satoshi UTXO, the first receiving ("external") address.</li>
<li>10,000,000 satoshi UTXO, the first change ("internal") address.</li>
</ol>
<p>We'll be sending this to two outputs:</p>
<ol>
<li>25,000,000 satoshis to a receivers' address.</li>
<li>4,990,000 satoshis back to us as change.</li>
</ol>
<p>The miner's fee will be 10,000 satoshis.</p>
<p>This is the <code>cargo</code> commands that you need to run this example:</p>
<pre><code class="language-bash">cargo add bitcoin --features "std, rand-std"
</code></pre>
<p>First we'll need to import the following:</p>
<pre><code class="language-rust">use std::collections::BTreeMap;
use std::str::FromStr;

use bitcoin::bip32::{ChildNumber, IntoDerivationPath, DerivationPath, Fingerprint, Xpriv, Xpub};
use bitcoin::hashes::Hash;
use bitcoin::key::UntweakedPublicKey;
use bitcoin::locktime::absolute;
use bitcoin::psbt::Input;
use bitcoin::secp256k1::{Secp256k1, Signing};
use bitcoin::{
    consensus, transaction, Address, Amount, Network, OutPoint, Psbt, ScriptBuf, Sequence,
    TapLeafHash, TapSighashType, Transaction, TxIn, TxOut, Txid, Witness, XOnlyPublicKey,
};</code></pre>
<p>Here is the logic behind these imports:</p>
<ul>
<li><code>std::collections::BTreeMap</code> is used to store the key-value pairs of the Tap Key origins PSBT input fields.</li>
<li><code>std::str::FromStr</code> is used to parse strings into Bitcoin primitives</li>
<li><code>bitcoin::bip32</code> is used to derive keys according to <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP 32</a></li>
<li><code>bitcoin::hashes::Hash</code> is used to hash data</li>
<li><code>bitcoin::key</code> is used to tweak keys according to <a href="https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki">BIP 340</a></li>
<li><code>bitcoin::locktime::absolute</code> is used to create a locktime</li>
<li><code>bitcoin::psbt</code> is used to construct and manipulate PSBTs</li>
<li><code>bitcoin::secp256k1</code> is used to sign transactions</li>
<li><code>bitcoin::consensus</code> is used to serialize the final signed transaction to a raw transaction</li>
<li><code>bitcoin::transaction</code> and <code>bitcoin::{Address, Network, OutPoint, ScriptBuf, Sequence, Transaction, TxIn, TxOut, Txid, Witness}</code> are used to construct transactions</li>
<li><code>bitcoin::{TapLeafHash, XOnlyPublicKey}</code> is used to construct Taproot inputs</li>
</ul>
<p>Next, we define the following constants:</p>
<pre><code class="language-rust"><span class="boring">use bitcoin::Amount;
</span>const XPRIV: &amp;str = "xprv9tuogRdb5YTgcL3P8Waj7REqDuQx4sXcodQaWTtEVFEp6yRKh1CjrWfXChnhgHeLDuXxo2auDZegMiVMGGxwxcrb2PmiGyCngLxvLeGsZRq";
const BIP86_DERIVATION_PATH: &amp;str = "m/86'/0'/0'";
const MASTER_FINGERPRINT: &amp;str = "9680603f";
const DUMMY_UTXO_AMOUNT_INPUT_1: Amount = Amount::from_sat(20_000_000);
const DUMMY_UTXO_AMOUNT_INPUT_2: Amount = Amount::from_sat(10_000_000);
const SPEND_AMOUNT: Amount = Amount::from_sat(25_000_000);
const CHANGE_AMOUNT: Amount = Amount::from_sat(4_990_000); // 10_000 sat fee.</code></pre>
<ul>
<li><code>XPRIV</code> is the extended private key that will be used to derive the keys for the Taproot inputs.</li>
<li><code>MASTER_FINGERPRINT</code> is the fingerprint of the master key.</li>
<li><code>BIP86_DERIVATION_PATH</code> is the derivation path for the BIP 86 key.
Since this is a mainnet example, we are using the path <code>m/86'/0'/0'</code>.</li>
<li><code>DUMMY_UTXO_AMOUNT_INPUT_1</code> is the amount of the dummy UTXO we will be spending from the first input.</li>
<li><code>DUMMY_UTXO_AMOUNT_INPUT_2</code> is the amount of the dummy UTXO we will be spending from the second input.</li>
<li><code>SPEND_AMOUNT</code> is the amount we will be spending from the dummy UTXO related to the first input.</li>
<li><code>CHANGE_AMOUNT</code><sup class="footnote-reference" id="fr-change-1"><a href="#footnote-change">1</a></sup> is the amount we will be sending back to ourselves as change.</li>
</ul>
<p>Before we can construct the transaction, we need to define some helper functions:</p>
<pre><code class="language-rust"><span class="boring">use std::collections::BTreeMap;
</span><span class="boring">use std::str::FromStr;
</span><span class="boring">
</span><span class="boring">use bitcoin::bip32::{ChildNumber, IntoDerivationPath, DerivationPath, Fingerprint, Xpriv, Xpub};
</span><span class="boring">use bitcoin::hashes::Hash;
</span><span class="boring">use bitcoin::key::UntweakedPublicKey;
</span><span class="boring">use bitcoin::secp256k1::{Secp256k1, Signing};
</span><span class="boring">use bitcoin::{Address, Amount, Network, OutPoint, TapLeafHash, Txid, TxOut, XOnlyPublicKey};
</span><span class="boring">
</span><span class="boring">const BIP86_DERIVATION_PATH: &amp;str = "m/86'/0'/0'";
</span><span class="boring">const DUMMY_UTXO_AMOUNT_INPUT_1: Amount = Amount::from_sat(20_000_000);
</span><span class="boring">const DUMMY_UTXO_AMOUNT_INPUT_2: Amount = Amount::from_sat(10_000_000);
</span>fn get_external_address_xpriv&lt;C: Signing&gt;(
    secp: &amp;Secp256k1&lt;C&gt;,
    master_xpriv: Xpriv,
    index: u32,
) -&gt; Xpriv {
    let derivation_path =
        BIP86_DERIVATION_PATH.into_derivation_path().expect("valid derivation path");
    let child_xpriv = master_xpriv
        .derive_priv(secp, &amp;derivation_path)
        .expect("valid child xpriv");
    let external_index = ChildNumber::from_normal_idx(0).unwrap();
    let idx = ChildNumber::from_normal_idx(index).expect("valid index number");

    child_xpriv
        .derive_priv(secp, &amp;[external_index, idx])
        .expect("valid xpriv")
}

fn get_internal_address_xpriv&lt;C: Signing&gt;(
    secp: &amp;Secp256k1&lt;C&gt;,
    master_xpriv: Xpriv,
    index: u32,
) -&gt; Xpriv {
    let derivation_path =
        BIP86_DERIVATION_PATH.into_derivation_path().expect("valid derivation path");
    let child_xpriv = master_xpriv
        .derive_priv(secp, &amp;derivation_path)
        .expect("valid child xpriv");
    let internal_index = ChildNumber::from_normal_idx(1).unwrap();
    let idx = ChildNumber::from_normal_idx(index).expect("valid index number");

    child_xpriv
        .derive_priv(secp, &amp;[internal_index, idx])
        .expect("valid xpriv")
}

fn get_tap_key_origin(
    x_only_key: UntweakedPublicKey,
    master_fingerprint: Fingerprint,
    path: DerivationPath,
) -&gt; BTreeMap&lt;XOnlyPublicKey, (Vec&lt;TapLeafHash&gt;, (Fingerprint, DerivationPath))&gt; {
    let mut map = BTreeMap::new();
    map.insert(x_only_key, (vec![], (master_fingerprint, path)));
    map
}

fn receivers_address() -&gt; Address {
    Address::from_str("bc1p0dq0tzg2r780hldthn5mrznmpxsxc0jux5f20fwj0z3wqxxk6fpqm7q0va")
        .expect("a valid address")
        .require_network(Network::Bitcoin)
        .expect("valid address for mainnet")
}

fn dummy_unspent_transaction_outputs() -&gt; Vec&lt;(OutPoint, TxOut)&gt; {
    let script_pubkey_1 =
        Address::from_str("bc1p80lanj0xee8q667aqcnn0xchlykllfsz3gu5skfv9vjsytaujmdqtv52vu")
            .unwrap()
            .require_network(Network::Bitcoin)
            .unwrap()
            .script_pubkey();

    let out_point_1 = OutPoint {
        txid: Txid::all_zeros(), // Obviously invalid.
        vout: 0,
    };

    let utxo_1 = TxOut {
        value: DUMMY_UTXO_AMOUNT_INPUT_1,
        script_pubkey: script_pubkey_1,
    };

    let script_pubkey_2 =
        Address::from_str("bc1pfd0jmmdnp278vppcw68tkkmquxtq50xchy7f6wdmjtjm7fgsr8dszdcqce")
            .unwrap()
            .require_network(Network::Bitcoin)
            .unwrap()
            .script_pubkey();

    let out_point_2 = OutPoint {
        txid: Txid::all_zeros(), // Obviously invalid.
        vout: 1,
    };

    let utxo_2 = TxOut {
        value: DUMMY_UTXO_AMOUNT_INPUT_2,
        script_pubkey: script_pubkey_2,
    };
    vec![(out_point_1, utxo_1), (out_point_2, utxo_2)]
}</code></pre>
<p><code>get_external_address_xpriv</code> and <code>get_internal_address_xpriv</code> generates the external and internal addresses extended private key,
given a master extended private key and an address index; respectively.
Note that these functions takes a <code>Secp256k1</code> that is
generic over the <a href="https://docs.rs/secp256k1/0.29.0/secp256k1/trait.Signing.html"><code>Signing</code></a> trait.
This is used to indicate that is an instance of <code>Secp256k1</code> and can be used for signing and other things.</p>
<p>The <code>get_tap_key_origin</code> function generates a Tap Key Origin key-value map,
which is a map of Taproot X-only keys to origin info and leaf hashes contained in it.
This is necessary to sign a Taproot input.</p>
<p><code>receivers_address</code> generates a receiver address.
In a real application this would be the address of the receiver.
We use the method <code>Address::from_str</code> to parse the string of addresses<sup class="footnote-reference" id="fr-arbitrary_address-1"><a href="#footnote-arbitrary_address">2</a></sup> into an <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/struct.Address.html"><code>Address</code></a>.
Hence, it is necessary to import the <code>std::str::FromStr</code> trait.
This is an arbitrary, however valid, Bitcoin mainnet address.
Hence we use the <code>require_network</code> method to ensure that the address is valid for mainnet.</p>
<p><code>dummy_unspent_transaction_outputs</code> generates a dummy unspent transaction output (UTXO).
This is a P2TR (<code>ScriptBuf::new_p2tr</code>) UTXO.</p>
<p>The UTXO has a dummy invalid transaction ID (<code>txid: Txid::all_zeros()</code>),
and any value of the <code>const DUMMY_UTXO_AMOUNT_N</code> that we defined earlier.
Note that the <code>vout</code> is set to <code>0</code> for the first UTXO and <code>1</code> for the second UTXO.
P2TR UTXOs could be tweaked (<a href="https://docs.rs/bitcoin/0.32.0/bitcoin/key/struct.TweakedPublicKey.html"><code>TweakedPublicKey</code></a>)
or untweaked (<a href="https://docs.rs/bitcoin/0.32.0/bitcoin/key/type.UntweakedPublicKey.html"><code>UntweakedPublicKey</code></a>).
We are using the latter, since we are not going to tweak the key.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.OutPoint.html"><code>OutPoint</code></a> struct to represent the transaction output.
Finally, we return vector of tuples <code>(out_point, utxo)</code>.</p>
<p>Now we are ready for our main function that will create, update, and sign a PSBT;
while also extracting a transaction that spends the <code>p2tr</code>s unspent outputs:</p>
<pre><code class="language-rust"><span class="boring">use std::collections::BTreeMap;
</span><span class="boring">use std::str::FromStr;
</span><span class="boring">
</span><span class="boring">use bitcoin::bip32::{ChildNumber, IntoDerivationPath, DerivationPath, Fingerprint, Xpriv, Xpub};
</span><span class="boring">use bitcoin::hashes::Hash;
</span><span class="boring">use bitcoin::key::UntweakedPublicKey;
</span><span class="boring">use bitcoin::locktime::absolute;
</span><span class="boring">use bitcoin::psbt::Input;
</span><span class="boring">use bitcoin::secp256k1::{Secp256k1, Signing};
</span><span class="boring">use bitcoin::{
</span><span class="boring">    consensus, transaction, Address, Amount, Network, OutPoint, Psbt, ScriptBuf, Sequence,
</span><span class="boring">    TapLeafHash, TapSighashType, Transaction, TxIn, TxOut, Txid, Witness, XOnlyPublicKey,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">const XPRIV: &amp;str = "xprv9tuogRdb5YTgcL3P8Waj7REqDuQx4sXcodQaWTtEVFEp6yRKh1CjrWfXChnhgHeLDuXxo2auDZegMiVMGGxwxcrb2PmiGyCngLxvLeGsZRq";
</span><span class="boring">const BIP86_DERIVATION_PATH: &amp;str = "m/86'/0'/0'";
</span><span class="boring">const MASTER_FINGERPRINT: &amp;str = "9680603f";
</span><span class="boring">const DUMMY_UTXO_AMOUNT_INPUT_1: Amount = Amount::from_sat(20_000_000);
</span><span class="boring">const DUMMY_UTXO_AMOUNT_INPUT_2: Amount = Amount::from_sat(10_000_000);
</span><span class="boring">const SPEND_AMOUNT: Amount = Amount::from_sat(25_000_000);
</span><span class="boring">const CHANGE_AMOUNT: Amount = Amount::from_sat(4_990_000); // 10_000 sat fee.
</span><span class="boring">
</span><span class="boring">fn get_external_address_xpriv&lt;C: Signing&gt;(
</span><span class="boring">    secp: &amp;Secp256k1&lt;C&gt;,
</span><span class="boring">    master_xpriv: Xpriv,
</span><span class="boring">    index: u32,
</span><span class="boring">) -&gt; Xpriv {
</span><span class="boring">    let derivation_path =
</span><span class="boring">       BIP86_DERIVATION_PATH.into_derivation_path().expect("valid derivation path");
</span><span class="boring">    let child_xpriv = master_xpriv
</span><span class="boring">        .derive_priv(secp, &amp;derivation_path)
</span><span class="boring">        .expect("valid child xpriv");
</span><span class="boring">    let external_index = ChildNumber::from_normal_idx(0).unwrap();
</span><span class="boring">    let idx = ChildNumber::from_normal_idx(index).expect("valid index number");
</span><span class="boring">
</span><span class="boring">    child_xpriv
</span><span class="boring">        .derive_priv(secp, &amp;[external_index, idx])
</span><span class="boring">        .expect("valid xpriv")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_internal_address_xpriv&lt;C: Signing&gt;(
</span><span class="boring">    secp: &amp;Secp256k1&lt;C&gt;,
</span><span class="boring">    master_xpriv: Xpriv,
</span><span class="boring">    index: u32,
</span><span class="boring">) -&gt; Xpriv {
</span><span class="boring">    let derivation_path =
</span><span class="boring">       BIP86_DERIVATION_PATH.into_derivation_path().expect("valid derivation path");
</span><span class="boring">    let child_xpriv = master_xpriv
</span><span class="boring">        .derive_priv(secp, &amp;derivation_path)
</span><span class="boring">        .expect("valid child xpriv");
</span><span class="boring">    let internal_index = ChildNumber::from_normal_idx(1).unwrap();
</span><span class="boring">    let idx = ChildNumber::from_normal_idx(index).expect("valid index number");
</span><span class="boring">
</span><span class="boring">    child_xpriv
</span><span class="boring">        .derive_priv(secp, &amp;[internal_index, idx])
</span><span class="boring">        .expect("valid xpriv")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_tap_key_origin(
</span><span class="boring">    x_only_key: UntweakedPublicKey,
</span><span class="boring">    master_fingerprint: Fingerprint,
</span><span class="boring">    path: DerivationPath,
</span><span class="boring">) -&gt; BTreeMap&lt;XOnlyPublicKey, (Vec&lt;TapLeafHash&gt;, (Fingerprint, DerivationPath))&gt; {
</span><span class="boring">    let mut map = BTreeMap::new();
</span><span class="boring">    map.insert(x_only_key, (vec![], (master_fingerprint, path)));
</span><span class="boring">    map
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn receivers_address() -&gt; Address {
</span><span class="boring">    Address::from_str("bc1p0dq0tzg2r780hldthn5mrznmpxsxc0jux5f20fwj0z3wqxxk6fpqm7q0va")
</span><span class="boring">        .expect("a valid address")
</span><span class="boring">        .require_network(Network::Bitcoin)
</span><span class="boring">        .expect("valid address for mainnet")
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn dummy_unspent_transaction_outputs() -&gt; Vec&lt;(OutPoint, TxOut)&gt; {
</span><span class="boring">    let script_pubkey_1 =
</span><span class="boring">        Address::from_str("bc1p80lanj0xee8q667aqcnn0xchlykllfsz3gu5skfv9vjsytaujmdqtv52vu")
</span><span class="boring">            .unwrap()
</span><span class="boring">            .require_network(Network::Bitcoin)
</span><span class="boring">            .unwrap()
</span><span class="boring">            .script_pubkey();
</span><span class="boring">
</span><span class="boring">    let out_point_1 = OutPoint {
</span><span class="boring">        txid: Txid::all_zeros(), // Obviously invalid.
</span><span class="boring">        vout: 0,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let utxo_1 = TxOut {
</span><span class="boring">        value: DUMMY_UTXO_AMOUNT_INPUT_1,
</span><span class="boring">        script_pubkey: script_pubkey_1,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let script_pubkey_2 =
</span><span class="boring">        Address::from_str("bc1pfd0jmmdnp278vppcw68tkkmquxtq50xchy7f6wdmjtjm7fgsr8dszdcqce")
</span><span class="boring">            .unwrap()
</span><span class="boring">            .require_network(Network::Bitcoin)
</span><span class="boring">            .unwrap()
</span><span class="boring">            .script_pubkey();
</span><span class="boring">
</span><span class="boring">    let out_point_2 = OutPoint {
</span><span class="boring">        txid: Txid::all_zeros(), // Obviously invalid.
</span><span class="boring">        vout: 1,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let utxo_2 = TxOut {
</span><span class="boring">        value: DUMMY_UTXO_AMOUNT_INPUT_2,
</span><span class="boring">        script_pubkey: script_pubkey_2,
</span><span class="boring">    };
</span><span class="boring">    vec![(out_point_1, utxo_1), (out_point_2, utxo_2)]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let secp = Secp256k1::new();

    // Get the individual xprivs we control. In a real application these would come from a stored secret.
    let master_xpriv = XPRIV.parse::&lt;Xpriv&gt;().expect("valid xpriv");
    let xpriv_input_1 = get_external_address_xpriv(&amp;secp, master_xpriv, 0);
    let xpriv_input_2 = get_internal_address_xpriv(&amp;secp, master_xpriv, 0);
    let xpriv_change = get_internal_address_xpriv(&amp;secp, master_xpriv, 1);

    // Get the PKs
    let (pk_input_1, _) = Xpub::from_priv(&amp;secp, &amp;xpriv_input_1)
        .public_key
        .x_only_public_key();
    let (pk_input_2, _) = Xpub::from_priv(&amp;secp, &amp;xpriv_input_2)
        .public_key
        .x_only_public_key();
    let (pk_change, _) = Xpub::from_priv(&amp;secp, &amp;xpriv_change)
        .public_key
        .x_only_public_key();

    // Get the Tap Key Origins
    // Map of tap root X-only keys to origin info and leaf hashes contained in it.
    let origin_input_1 = get_tap_key_origin(
        pk_input_1,
        Fingerprint::from_str(MASTER_FINGERPRINT).unwrap(),
        "m/86'/0'/0'/0/0".into_derivation_path().expect("valid derivation path"), // First external address.
    );
    let origin_input_2 = get_tap_key_origin(
        pk_input_2,
        Fingerprint::from_str(MASTER_FINGERPRINT).unwrap(),
        "m/86'/0'/0'/1/0".into_derivation_path().expect("valid derivation path"), // First internal address.
    );
    let origins = [origin_input_1, origin_input_2];

    // Get the unspent outputs that are locked to the key above that we control.
    // In a real application these would come from the chain.
    let utxos: Vec&lt;TxOut&gt; = dummy_unspent_transaction_outputs()
        .into_iter()
        .map(|(_, utxo)| utxo)
        .collect();

    // Get the addresses to send to.
    let address = receivers_address();

    // The inputs for the transaction we are constructing.
    let inputs: Vec&lt;TxIn&gt; = dummy_unspent_transaction_outputs()
        .into_iter()
        .map(|(outpoint, _)| TxIn {
            previous_output: outpoint,
            script_sig: ScriptBuf::default(),
            sequence: Sequence::ENABLE_RBF_NO_LOCKTIME,
            witness: Witness::default(),
        })
        .collect();

    // The spend output is locked to a key controlled by the receiver.
    let spend = TxOut {
        value: SPEND_AMOUNT,
        script_pubkey: address.script_pubkey(),
    };

    // The change output is locked to a key controlled by us.
    let change = TxOut {
        value: CHANGE_AMOUNT,
        script_pubkey: ScriptBuf::new_p2tr(&amp;secp, pk_change, None), // Change comes back to us.
    };

    // The transaction we want to sign and broadcast.
    let unsigned_tx = Transaction {
        version: transaction::Version::TWO,  // Post BIP 68.
        lock_time: absolute::LockTime::ZERO, // Ignore the locktime.
        input: inputs,                       // Input is 0-indexed.
        output: vec![spend, change],         // Outputs, order does not matter.
    };

    // Now we'll start the PSBT workflow.
    // Step 1: Creator role; that creates,
    // and add inputs and outputs to the PSBT.
    let mut psbt = Psbt::from_unsigned_tx(unsigned_tx).expect("Could not create PSBT");

    // Step 2:Updater role; that adds additional
    // information to the PSBT.
    let ty = TapSighashType::All.into();
    psbt.inputs = vec![
        Input {
            witness_utxo: Some(utxos[0].clone()),
            tap_key_origins: origins[0].clone(),
            tap_internal_key: Some(pk_input_1),
            sighash_type: Some(ty),
            ..Default::default()
        },
        Input {
            witness_utxo: Some(utxos[1].clone()),
            tap_key_origins: origins[1].clone(),
            tap_internal_key: Some(pk_input_2),
            sighash_type: Some(ty),
            ..Default::default()
        },
    ];

    // Step 3: Signer role; that signs the PSBT.
    psbt.sign(&amp;master_xpriv, &amp;secp).expect("valid signature");

    // Step 4: Finalizer role; that finalizes the PSBT.
    psbt.inputs.iter_mut().for_each(|input| {
        let script_witness = Witness::p2tr_key_spend(&amp;input.tap_key_sig.unwrap());
        input.final_script_witness = Some(script_witness);

        // Clear all the data fields as per the spec.
        input.partial_sigs = BTreeMap::new();
        input.sighash_type = None;
        input.redeem_script = None;
        input.witness_script = None;
        input.bip32_derivation = BTreeMap::new();
    });

    // BOOM! Transaction signed and ready to broadcast.
    let signed_tx = psbt.extract_tx().expect("valid transaction");
    let serialized_signed_tx = consensus::encode::serialize_hex(&amp;signed_tx);
    println!("Transaction Details: {:#?}", signed_tx);
    // check with:
    // bitcoin-cli decoderawtransaction &lt;RAW_TX&gt; true
    println!("Raw Transaction: {}", serialized_signed_tx);
}</code></pre>
<p>Let's go over the main function code block by block.</p>
<p><code>let secp = Secp256k1::new();</code> creates a new <code>Secp256k1</code> context with all capabilities.
Since we added the <code>rand-std</code> feature to our <code>Cargo.toml</code>,</p>
<p>Next, we get the individual extended private keys (xpriv) that we control.
These are:</p>
<ul>
<li>the master xpriv,</li>
<li>the xprivs for inputs 1 and 2;
these are done with the <code>get_external_address_xpriv</code> and <code>get_internal_address_xpriv</code> functions.</li>
<li>the xpriv for the change output, also using the <code>get_internal_address_xpriv</code> function.</li>
</ul>
<p>Now, we need the Taproot X-only keys along the origin info and leaf hashes contained in it.
This is done with the <code>get_tap_key_origin</code> function.</p>
<p>The inputs for the transaction we are constructing,
here named <code>utxos</code>,
are created with the <code>dummy_unspent_transaction_outputs</code> function.
<code>let address = receivers_address();</code> generates a receiver's address <code>address</code>.
All of these are helper functions that we defined earlier.</p>
<p>In <code>let input = TxIn {...}</code> we are instantiating the inputs for the transaction we are constructing
Inside the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.TxIn.html"><code>TxIn</code></a> struct we are setting the following fields:</p>
<ul>
<li><code>previous_output</code> is the outpoint of the dummy UTXO we are spending; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.OutPoint.html"><code>OutPoint</code></a> type.</li>
<li><code>script_sig</code> is the script code required to spend an output; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html"><code>ScriptBuf</code></a> type.
We are instantiating a new empty script with <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html#method.new"><code>ScriptBuf::new()</code></a>.</li>
<li><code>sequence</code> is the sequence number; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Sequence.html"><code>Sequence</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Sequence.html#associatedconstant.ENABLE_RBF_NO_LOCKTIME"><code>ENABLE_RBF_NO_LOCKTIME</code></a> constant.</li>
<li><code>witness</code> is the witness stack; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/witness/struct.Witness.html"><code>Witness</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/witness/struct.Witness.html#impl-Default"><code>default</code></a> method to create an empty witness that will be filled in later after signing.
This is possible because <code>Witness</code> implements the <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a> trait.</li>
</ul>
<p>In <code>let spend = TxOut {...}</code> we are instantiating the spend output.
Inside the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.TxOut.html"><code>TxOut</code></a> struct we are setting the following fields:</p>
<ul>
<li><code>value</code> is the amount we are spending; it is a <a href="https://doc.rust-lang.org/std/primitive.u64.html"><code>u64</code></a> type.
We are using the <code>const SPEND_AMOUNT</code> that we defined earlier.</li>
<li><code>script_pubkey</code> is the script code required to spend a P2TR output; it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html"><code>ScriptBuf</code></a> type.
We are using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/address/struct.Address.html#method.script_pubkey"><code>script_pubkey</code></a> method to generate the script pubkey from the receivers address.
This will lock the output to the receiver's address.</li>
</ul>
<p>In <code>let change = TxOut {...}</code> we are instantiating the change output.
It is very similar to the <code>spend</code> output, but we are now using the <code>const CHANGE_AMOUNT</code> that we defined earlier<sup class="footnote-reference" id="fr-spend-1"><a href="#footnote-spend">3</a></sup>.
This is done by setting the <code>script_pubkey</code> field to <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/script/struct.ScriptBuf.html#method.new_p2tr"><code>ScriptBuf::new_p2tr(...)</code></a>,
which generates P2TR-type of script pubkey.</p>
<p>In <code>let unsigned_tx = Transaction {...}</code> we are instantiating the transaction we want to sign and broadcast using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/transaction/struct.Transaction.html"><code>Transaction</code></a> struct.
We set the following fields:</p>
<ul>
<li><code>version</code> is the transaction version; it can be a <a href="https://doc.rust-lang.org/std/primitive.u32.html"><code>i32</code></a> type.
However it is best to use the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/block/struct.Version.html"><code>Version</code></a> struct.
We are using version <code>TWO</code> which means that <a href="https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki">BIP 68</a> applies.</li>
<li><code>lock_time</code> is the transaction lock time;
it is a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/locktime/absolute/enum.LockTime.html"><code>LockTime</code></a> enum.
We are using the constant <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/blockdata/locktime/absolute/enum.LockTime.html#associatedconstant.ZERO"><code>ZERO</code></a>
This will make the transaction valid immediately.</li>
<li><code>input</code> is the input vector; it is a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;TxIn&gt;</code></a> type.
We are using the <code>input</code> variable that we defined earlier wrapped in the <a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a> macro for convenient initialization.</li>
<li><code>output</code> is the output vector; it is a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;TxOut&gt;</code></a> type.
We are using the <code>spend</code> and <code>change</code> variables that we defined earlier wrapped in the <a href="https://doc.rust-lang.org/std/macro.vec.html"><code>vec!</code></a> macro for convenient initialization.</li>
</ul>
<p>Now we are ready to start our PSBT workflow.</p>
<p>The first step is the Creator role.
We create a PSBT from the unsigned transaction using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/psbt/struct.Psbt.html#method.from_unsigned_tx"><code>Psbt::from_unsigned_tx</code></a> method.</p>
<p>Next, we move to the Updater role.
We add additional information to the PSBT.
This is done by setting the <code>psbt.inputs</code> field to a vector of <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/psbt/struct.Input.html"><code>Input</code></a> structs.
In particular, we set the following fields:</p>
<ul>
<li><code>witness_utxo</code> is the witness UTXO; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;TxOut&gt;</code></a> type.
We are using the <code>utxos</code> vector that we defined earlier.</li>
<li><code>tap_key_origins</code> is the Tap Key Origins; it is a <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap&lt;XOnlyPublicKey, (Vec&lt;TapLeafHash&gt;, (Fingerprint, DerivationPath))&gt;</code></a> type.
We are using the <code>origins</code> vector that we defined earlier.</li>
<li><code>tap_internal_key</code> is the Taproot internal key; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;XOnlyPublicKey&gt;</code></a> type.</li>
<li><code>sighash_type</code> is the sighash type; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;PsbtSighashType&gt;</code></a> type.</li>
</ul>
<p>All the other fields are set to their default values using the <a href="https://doc.rust-lang.org/std/default/trait.Default.html#tymethod.default"><code>Default::default()</code></a> method.</p>
<p>The following step is the Signer role.
Here is were we sign the PSBT with the
<a href="https://docs.rs/bitcoin/0.32.0/bitcoin/psbt/struct.Psbt.html#method.sign"><code>sign</code></a> method.
This method takes the master extended private key and the <code>Secp256k1</code> context as arguments.
It attempts to create all the required signatures for this PSBT using the extended private key.</p>
<p>Finally, we move to the Finalizer role.
Here we finalize the PSBT, making it ready to be extracted into a signed transaction,
and if necessary, broadcasted to the Bitcoin network.
This is done by setting the following fields:</p>
<ul>
<li><code>final_script_witness</code> is the final script witness; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;Witness&gt;</code></a> type.
We are using the <code>Witness::p2tr_key_spend()</code> method to create a witness required to do a key path spend of a P2TR output.</li>
<li><code>partial_sigs</code> is the partial signatures; it is a <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap&lt;XOnlyPublicKey, Vec&lt;u8&gt;&gt;</code></a> type.
We are using an empty map.</li>
<li><code>sighash_type</code> is the sighash type; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;PsbtSighashType&gt;</code></a> type.
We are using the <code>None</code> value.</li>
<li><code>redeem_script</code> is the redeem script; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;ScriptBuf&gt;</code></a> type.
We are using the <code>None</code> value.</li>
<li><code>witness_script</code> is the witness script; it is an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option&lt;ScriptBuf&gt;</code></a> type.</li>
<li><code>bip32_derivation</code> is the BIP 32 derivation; it is a <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap&lt;Xpub, (Fingerprint, DerivationPath)&gt;</code></a> type.
We are using an empty map.</li>
</ul>
<p>Finally, we extract the signed transaction from the PSBT using the <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/psbt/struct.Psbt.html#method.extract_tx"><code>extract_tx</code></a> method.</p>
<p>As the last step we print both the transaction details and the raw transaction
to the terminal using the <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!</code></a> macro.
This transaction is now ready to be broadcast to the Bitcoin network.</p>
<p>For anything in production, the step 4 (Finalizer) should be done with the
<a href="https://docs.rs/miniscript/11.0.0/miniscript/psbt/trait.PsbtExt.html"><code>psbt::PsbtExt</code> from the <code>miniscript</code> crate</a> trait.
It provides a
<a href="https://docs.rs/miniscript/11.0.0/miniscript/psbt/trait.PsbtExt.html#tymethod.finalize_mut"><code>.finalize_mut</code></a>
to a <a href="https://docs.rs/bitcoin/0.32.0/bitcoin/psbt/struct.Psbt.html"><code>Psbt</code></a> object,
which takes in a mutable reference to <code>Psbt</code> and populates the <code>final_witness</code> and <code>final_scriptsig</code> for all inputs.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-change">
<p>Please note that the <code>CHANGE_AMOUNT</code> is not the same as the <code>DUMMY_UTXO_AMOUNT_INPUT_N</code>s minus the <code>SPEND_AMOUNT</code>.
This is due to the fact that we need to pay a miner's fee for the transaction. <a href="#fr-change-1">↩</a></p>
</li>
<li id="footnote-arbitrary_address">
<p>this is an arbitrary mainnet addresses from block 805222. <a href="#fr-arbitrary_address-1">↩</a></p>
</li>
<li id="footnote-spend">
<p>And also we are locking the output to an address that we control:
the <code>internal_key</code> public key hash that we generated earlier. <a href="#fr-spend-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
